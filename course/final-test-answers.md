[← Оглавление](../README.md)

# Финальный тест — Ключ ответов

Ответы и объяснения к [финальному тесту](./final-test.md).

---

## Вопрос 1: Реалистичные ожидания (Модуль 1)

**Правильный ответ:** B

**Почему B:** Агент уровня 4-5 повышает продуктивность в разы, но не заменяет команду. Сеньор с агентами может закрывать работу 2-3 разработчиков, но не пяти.

Задачи, которые агент не закроет:
- Архитектурные решения с бизнес-контекстом
- Код с неочевидными требованиями
- Отладка сложных багов в legacy-системах
- Менторинг джуниоров

Огромный объём работы уходит на ревью AI-кода, настройку процессов, разрешение блокеров. Техлид, который считает агента полной заменой людей, — скорее всего не имеет реального опыта работы с AI на scale.

---

## Вопрос 2: Выбор инструмента (Модуль 2)

**Правильный ответ:** C

**Почему C:** Задача массовая, по шаблону, с формальными критериями (тесты должны пройти). Это идеальный кейс для дешёвой модели в агентном режиме.

DeepSeek R1 стоит $0.70/$2.50 за 1М токенов — в 10-30 раз дешевле Claude. OpenCode — бесплатный CLI-агент с поддержкой DeepSeek. Итого: ~$5-10 на API вместо $100 на Claude Max.

Почему не другие варианты:
- **A (ChatGPT Plus):** требует ручного копирования кода — неэффективно для 15 моделей
- **B (Cursor Pro):** Sonnet дороже DeepSeek в 4-5 раз без преимущества для boilerplate
- **D:** Opus для boilerplate — как Ferrari для поездки в магазин

---

## Вопрос 3: Улучшение промпта (Модуль 3)

**Правильный ответ:** C

**Почему C:** «Добавь кеширование» — два антипаттерна сразу: нечёткая формулировка и отсутствие контекста.

Агент не знает:
- Какие endpoints кешировать
- Где хранить кеш (in-memory, Redis, memcached)
- TTL — 1 минута, 1 час, 24 часа?
- Когда инвалидировать кеш
- Как обрабатывать cache stampede

Правильный промпт даёт всё это явно: технологию, TTL, условия инвалидации, ссылку на существующий клиент.

Почему не другие варианты:
- **A:** смена модели не поможет — Opus с плохим промптом даст плохой результат
- **B:** 5 страниц ТЗ избыточно, достаточно 10-15 строк с чёткими критериями
- **D:** перезапуск — повторение той же ошибки

---

## Вопрос 4: Постановка задачи агенту (Модуль 4)

**Правильный ответ:** B

**Почему B:** Код без тестов нельзя принимать, даже если компилируется. Компиляция проверяет синтаксис, но не логику. Авторизация — критичный участок, ошибки дорого стоят.

Правильный workflow:
1. Попросить агента написать тесты: JWT validation, token expiry, refresh flow, unauthorized access
2. Запустить тесты — они должны пройти
3. Сделать code review: нет захардкоженных секретов? правильно реализован refresh? нет SQL-инъекций?
4. Только после прохождения тестов и ревью — коммит

Почему не другие варианты:
- **A:** «компилируется = работает» — типичная ошибка новичка
- **C:** 500 строк для авторизации с JWT + refresh + middleware — норма, не overreaction
- **D:** объяснение не заменяет тесты

---

## Вопрос 5: Надзор и ревью (Модуль 4)

**Правильный ответ:** B

**Почему B:** Агент экспортировал `SELECT * FROM users` — это приватные данные (email, password_hash, телефоны, адреса). Проблему нужно зафиксировать как правило.

Правильный подход:
1. В `AGENTS.md` добавить правило: «При экспорте пользовательских данных ВСЕГДА фильтруй приватные поля. Экспортируй только: id, username, created_at, last_login»
2. Попросить агента переделать экспорт с фильтрацией
3. Добавить тест, который проверяет отсутствие приватных полей

Почему не другие варианты:
- **A:** игнорирование security issue
- **C:** тип БД не влияет на проблему
- **D:** YOLO допустим в изолированных окружениях (git worktree внутри Docker)

---

## Вопрос 6: Выбор артефакта (Модуль 5)

**Правильный ответ:** B

**Почему B:** Если правило обязательное для всей команды (Repository pattern для БД) — оно идёт в Constitution/AGENTS.md. Constitution читают все агенты при каждой задаче.

В Constitution добавить в раздел «Обязательные паттерны»: «Все SQL-запросы ТОЛЬКО через Repository pattern. Запрещено писать SQL прямо в handlers/controllers.»

Почему не другие варианты:
- **A (Trace-файл):** память одного агента об одной задаче, другие агенты его не читают
- **C (Feature plan):** правило потеряется после завершения плана
- **D (ручные правки):** техдолг и потеря времени

---

## Вопрос 7: Когда нужен MCP (Модуль 6)

**Правильный ответ:** B

**Почему B:** Без MCP — 5-10 минут ручных операций на каждую задачу. При 10 задачах в неделю = 50-100 минут ручной работы.

С Jira MCP агент делает всё автоматически:
- Читает PROJ-456 через API
- Получает description и acceptance criteria
- Реализует фичу
- Создаёт worklog с комментарием
- Обновляет статус на «Code Review»

Почему не другие варианты:
- **C:** агент не может «зайти в браузер» без специального MCP-сервера (Puppeteer)
- **D:** URL в промпте не даёт доступ к данным задачи — нужен API через MCP

---

## Вопрос 8: Выбор паттерна оркестрации (Модуль 7)

**Правильный ответ:** C

**Почему C:** API endpoint + Email + SMS + UI — естественное разделение на независимые части.

Параллельная схема:
- **Агент 1:** API endpoint (CRUD) + интеграция SendGrid
- **Агент 2:** интеграция Twilio для SMS
- **Агент 3:** React-компонент для UI настроек

Все три работают параллельно в изолированных git worktrees. Время: ~40 минут вместо 2 часов последовательно.

Почему не другие варианты:
- **A (последовательно):** медленно и неэффективно
- **B (генератор + ревьюер):** 2× дороже, нет особых рисков для этой задачи
- **D (иерархия):** избыточно для задачи с чёткими границами

---

## Вопрос 9: Разрешение конфликта (Модуль 7)

**Правильный ответ:** C

**Почему C:** Два агента добавили разные функции в один файл — это разрешаемый конфликт без потерь.

Агент-арбитр получает:
1. Исходный файл `validators.ts`
2. Изменения агента 1 (validateEmail)
3. Изменения агента 2 (validatePhone)
4. Генерирует финальную версию с обеими функциями

Это автоматизируемый процесс для простых конфликтов: добавление независимых функций, импортов, экспортов.

Почему не другие варианты:
- **A:** задача выполнена, переделывать не нужно
- **B:** один агент ждёт — теряем параллельность
- **D:** два файла для двух функций — over-engineering для одного модуля

> **Исключение:** если оба агента изменили одну функцию по-разному — нужен ручной ревью.

---

## Вопрос 10: Безопасность (Модуль 8)

**Правильный ответ:** B

**Почему B:** API-токены НИКОГДА не хранятся в plain text в конфигах, которые могут попасть в Git.

Правильный подход:
1. Токен в переменной окружения: `export FIGMA_ACCESS_TOKEN="..."` в `~/.zshrc`
2. Конфиг ссылается на переменную: `"env": { "FIGMA_ACCESS_TOKEN": "${FIGMA_ACCESS_TOKEN}" }`
3. Если `mcp.json` попадёт в Git — там будет `${FIGMA_ACCESS_TOKEN}`, а не реальный токен

Почему не другие варианты:
- **A:** токен в plain text — instant security breach в публичном репозитории
- **C:** `.env` + `.gitignore` работает, но легко забыть в новом проекте; переменные окружения надёжнее
- **D:** AI-инструменты могут логировать данные, отправлять в API для обучения или показывать в trace-файлах
