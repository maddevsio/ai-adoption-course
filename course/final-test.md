[← Оглавление](../README.md)

# Финальный тест

Тест из 10 сценарных вопросов, покрывающих ключевые знания всех 8 модулей курса. Каждый вопрос основан на реальной ситуации из практики разработчика.

> Ключ ответов с объяснениями — в [final-test-answers.md](./final-test-answers.md).

---

## Вопрос 1: Реалистичные ожидания (Модуль 1)

Ты на собеседовании в стартап. Техлид говорит: "У нас есть Claude Code, поэтому мы не нанимаем мидл-разработчиков. Один сеньор с агентом заменяет команду из 5 человек." Как правильно оценить эту ситуацию?

**A)** Отлично! Агент действительно может полностью заменить мидл-разработчиков, я буду работать с агентом один на один

**B)** Это red flag: агент — инструмент для усиления продуктивности, а не замена команды. Сеньор будет перегружен ревью AI-кода, архитектурой, блокерами

**C)** Агент может заменить мидлов, если правильно настроить MCP-серверы и оркестрацию

**D)** Нужно попросить Claude Max подписку и тогда это реально

---

## Вопрос 2: Выбор инструмента (Модуль 2)

Тебе нужно добавить CRUD endpoints для 15 моделей данных. Endpoints простые, по одинаковому шаблону. У тебя ограниченный бюджет $30/месяц. Какую стратегию выбрать?

**A)** Использовать ChatGPT Plus ($20/мес) — описываешь задачу в чате, копируешь код руками

**B)** Cursor Pro ($20/мес) + агент в Agent Mode пишет все endpoints последовательно, используя Claude Sonnet 4.5

**C)** OpenCode (бесплатно) + DeepSeek R1 API ($5-10/мес) — агент массово генерирует endpoints, проверка через тесты

**D)** Claude Code Max ($100/мес) — максимальное качество кода через Opus 4.6

---

## Вопрос 3: Улучшение промпта (Модуль 3)

Ты даёшь агенту задачу: "Добавь кеширование в API". Агент возвращает код, который добавляет in-memory cache без TTL, без инвалидации, кеширует всё подряд. Что не так с промптом?

**A)** Нужно было указать модель Claude Opus вместо Sonnet

**B)** Промпт слишком короткий — нужно было написать 5 страниц детального ТЗ

**C)** Отсутствует контекст и критерии: какие endpoints кешировать, где хранить кеш (Redis?), TTL для разных данных, как инвалидировать

**D)** Агент просто плохо справился, нужно перезапустить с тем же промптом

---

## Вопрос 4: Постановка задачи агенту (Модуль 4)

Ты ставишь агенту задачу: "Добавь авторизацию в приложение". Агент написал 500 строк кода, добавил JWT, refresh tokens, middleware. Код компилируется, но тестов нет. Что делать?

**A)** Закоммитить — код компилируется, значит работает

**B)** Попросить агента написать тесты, потом сделать полное ревью кода и тестов

**C)** Удалить и переписать руками — слишком много кода, агент не справился

**D)** Попросить агента объяснить каждую строку кода

---

## Вопрос 5: Надзор и ревью (Модуль 4)

Агент работает в YOLO-режиме (без подтверждений) над фичей "экспорт данных в CSV". Ты видишь в логах: агент прочитал файл `users.db`, выполнил `SELECT * FROM users`, записал в `export.csv`, закоммитил. Какая проблема?

**A)** Нет проблемы — агент выполнил задачу автономно, как и должен

**B)** Агент экспортировал ВСЕ данные пользователей, включая приватные (email, пароли) без фильтрации — security issue

**C)** Агент должен был использовать PostgreSQL вместо SQLite

**D)** YOLO-режим вообще нельзя использовать

---

## Вопрос 6: Выбор артефакта (Модуль 5)

У тебя проект с 3 агентами, которые работают параллельно. Агент 1 постоянно забывает использовать Repository pattern для БД и пишет SQL прямо в handlers. Агент 2 и 3 делают правильно. Куда нужно добавить правило?

**A)** В trace-файл агента 1 — чтобы он запомнил

**B)** В Constitution (AGENTS.md) — это обязательное правило для всех агентов

**C)** В feature plan — чтобы агент 1 знал об этом для текущей задачи

**D)** Никуда, просто исправлять вручную каждый раз

---

## Вопрос 7: Когда нужен MCP (Модуль 6)

Ты работаешь над задачей из Jira: "PROJ-456: Add user profile page". Тебе нужно: 1) Прочитать детальное описание из Jira, 2) Реализовать фичу, 3) Залогировать время работы в Jira. Какой подход оптимален?

**A)** Вручную открыть Jira → скопировать описание → дать агенту → реализовать → вручную залогировать время

**B)** Установить Jira MCP-сервер → агент читает задачу из Jira, реализует, автоматически логирует время

**C)** Попросить агента самому зайти в Jira через браузер

**D)** MCP не нужен, достаточно скопировать URL задачи в промпт

---

## Вопрос 8: Выбор паттерна оркестрации (Модуль 7)

Фича "Система уведомлений" состоит из: 1) API endpoint POST /notifications, 2) Email-сервис через SendGrid, 3) SMS-сервис через Twilio, 4) React UI для настроек уведомлений. Задачи независимые. Как организовать работу 3 агентов?

**A)** Последовательно: агент 1 делает API → агент 2 делает Email → агент 3 делает SMS → агент 1 делает UI

**B)** Паттерн "Генератор + Ревьюер": один агент пишет весь код, другой проверяет

**C)** Паттерн "Декомпозиция": агент 1 — API + Email (backend), агент 2 — SMS (backend), агент 3 — UI (frontend). Все работают параллельно

**D)** Паттерн "Иерархия RPI→R": агент-архитектор планирует → агент-разработчик реализует всё → агент-QA тестирует

---

## Вопрос 9: Разрешение конфликта (Модуль 7)

Два агента работали параллельно: агент 1 добавил валидацию email в файл `utils/validators.ts`, агент 2 добавил валидацию телефона в тот же файл. Оба создали PR. При слиянии — merge conflict в `validators.ts`. Как решить?

**A)** Отклонить оба PR и переделать задачу с одним агентом

**B)** Выбрать один PR случайно, второй агент пусть переделает с учётом изменений первого

**C)** Агент-арбитр читает оба варианта кода и генерирует объединённую версию с обеими валидациями

**D)** Удалить файл и создать два отдельных файла: `emailValidator.ts` и `phoneValidator.ts`

---

## Вопрос 10: Безопасность (Модуль 8)

Ты настраиваешь Figma MCP-сервер для design-to-code workflow. В конфигурации `~/.claude/mcp.json` нужно указать `FIGMA_ACCESS_TOKEN`. Где правильно хранить токен?

**A)** Прямо в `mcp.json`: `"FIGMA_ACCESS_TOKEN": "figd_abc123..."`

**B)** В переменной окружения: `export FIGMA_ACCESS_TOKEN="figd_abc123..."` в `~/.bashrc`, в mcp.json: `"FIGMA_ACCESS_TOKEN": "${FIGMA_ACCESS_TOKEN}"`

**C)** В `.env` файле в корне проекта, добавить `.env` в `.gitignore`

**D)** В Claude Code нет риска утечки, можно хранить где удобно

---

## Результаты

**9-10 правильных ответов:** Отлично! Вы усвоили материал курса и готовы применять AI-инструменты на практике на уровне 3-4.

**7-8 правильных ответов:** Хорошо! Основные концепции поняты, рекомендуется повторить слабые места (посмотрите, в каких модулях ошиблись).

**5-6 правильных ответов:** Удовлетворительно. Базовое понимание есть, но нужно глубже изучить модули 4-7 (агенты, SDD, MCP, оркестрация).

**Меньше 5 правильных ответов:** Рекомендуется пересмотреть курс, особенно практические модули. Попробуйте выполнить упражнения из practice.md для каждого модуля.

---

## Следующие шаги

После прохождения теста:

1. **Проверьте свою модель зрелости** — пройдите самодиагностику из Модуля 1 ещё раз, сравните результаты с началом курса
2. **Выберите проект для практики** — примените знания на реальной задаче (фича, рефакторинг, миграция)
3. **Настройте свой стек** — установите инструменты под ваш бюджет и задачи (см. Модуль 2)
4. **Создайте AGENTS.md** для своего проекта — начните управлять контекстом (см. Модуль 5)
5. **Присоединяйтесь к сообществу** — делитесь опытом, учитесь у других (Discord, GitHub, X/Twitter)

Удачи в работе с AI-инструментами!
---

[← Чеклисты для работы с AI-кодом](module-8-responsibility/practice/01-checklists.md) | [Оглавление](../README.md)
