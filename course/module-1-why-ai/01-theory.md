[← Оглавление](../../README.md)

# Уровни зрелости использования ИИ в разработке

> [Диаграмма: 5 уровней зрелости](./diagrams/maturity-levels.md)

## Уровень 1: Начинающий (чат-помощник)

ИИ как улучшенная поисковая система. Вы задаёте вопрос в ChatGPT, Gemini или DeepSeek, копируете ответ. Использование эпизодичное — когда застряли.

**Инструменты:** браузерные чаты, разовые запросы, без интеграции в IDE.
**Промптинг:** простые вопросы — "как сделать X?", "напиши код для Y". Контекст почти не даётся.
**Надзор:** слабый. Код копируется "как есть", проверка — "работает / не работает".
**Автономность:** нулевая. Только ответы на прямые запросы.

### Типичные проблемы

- **Слепое доверие.** Код вставляется без понимания. Может содержать уязвимости или устаревшие API.
- **Нет контекста.** ИИ не знает вашу кодовую базу, версии библиотек, стиль команды.
- **Повторяющиеся ошибки.** Нет понимания, как сформулировать промпт для нужного результата.
- **Неэффективность.** Копирование между браузером и IDE, потеря контекста между сессиями.

### Путь на следующий уровень

1. Проверяйте код от ИИ: читайте, тестируйте, ищите проблемы.
2. Формулируйте точнее: добавляйте контекст (язык, фреймворк, версии).
3. Попробуйте IDE-копилот (GitHub Copilot, Tabnine) — не переключайтесь между браузером и редактором.

> **Пример:** Разработчик копирует код из ChatGPT без проверки — тратит 2 часа на отладку устаревшего примера.

---

## Уровень 2: Интегрированный помощник (копилот в IDE)

ИИ встроен в IDE и работает постоянно. Вы видите автодополнения прямо в коде. Развивается интуиция — когда доверять подсказке, а когда нет.

**Инструменты:** IDE-копилоты (GitHub Copilot, Tabnine). Работают в фоне, предлагают код по мере набора.
**Промптинг:** реактивный — комментарии и имена переменных как подсказки. Нет управления контекстом.
**Надзор:** растущий. Замечаете устаревший код, но проверка выборочная.
**Автономность:** минимальная. Inline-автодополнение на уровне строк и блоков.

### Типичные проблемы

- **Реактивность.** Вы реагируете на предложения, а не ставите целенаправленные задачи.
- **Примитивный промптинг.** Промпты — комментарии вроде `// функция для сортировки`. Нет примеров и контекста.
- **Ограниченный масштаб.** Копилот поможет написать метод, но не проведёт рефакторинг модуля.
- **Зависимость от открытых файлов.** Модель видит только текущий файл.

### Путь на следующий уровень

1. Используйте Copilot Chat для задач: "напиши тесты для модуля", "отрефактори метод".
2. Попробуйте агентные инструменты: Cursor Agent mode, Claude Code, Antigravity.
3. Изучайте промпт-инжиниринг: few-shot примеры, пошаговые задачи, роли.

> **Пример:** Frontend-разработчик ускорил рутину вдвое с Copilot, но рефакторинг модулей не получается — промпты недостаточно чёткие.

---

## Уровень 3: Agentic developer

Вы делегируете агенту целые задачи. Агент читает файлы, пишет код, запускает команды, итерирует. Ваша роль — постановщик задач и ревьюер.

**Инструменты:** AI-IDE и CLI-агенты (Cursor Agent mode, Claude Code, Antigravity). Агент работает с файлами, git, terminal.
**Промптинг:** задачи вместо вопросов. Структура: контекст → задача → критерии приёмки.
**Надзор:** активный. Проверяете файлы, команды, результаты. Знаете, когда агент ошибается.
**Автономность:** средняя. Агент выполняет задачу целиком под вашим контролем.

> **AGENTS.md** — файл с правилами для агента, "конституция" проекта. Подробнее в Модуле 4.

### Типичные проблемы

- **Одна задача за раз.** Несколько агентов параллельно — контекст путается, файлы конфликтуют.
- **Потеря фокуса.** В длинных сессиях контекст "размывается". Агент уходит от исходной задачи.
- **Архитектура — слабое место.** Агент хорош в реализации по спецификации, но плох в проектировании с нуля.
- **Ручной контроль.** Проверка, тесты, слияние веток — всё делаете вы.

### Путь на следующий уровень

1. Пишите спецификации: планы фичей, ADR.
2. Управляйте контекстом: Constitution, memory, guidelines. Подробнее в Модуле 5.
3. Расширяйте агента через MCP-серверы (git, БД, Jira, браузер, Figma).

> **Пример:** Fullstack-разработчик ставит агенту задачу с endpoint, моделями и тестами — результат за 15 минут вместо часа. Архитектурный рефакторинг делает сам.

---

## Уровень 4: Продвинутый Agentic developer

Один агент как основной интерфейс, расширенный через **MCP** (Model Context Protocol — подключение внешних инструментов, подробнее в Модуле 6). Чёткие правила, примеры и инструменты дают агенту больше автономии.

**Инструменты:** один агент + MCP-серверы (git, БД, Jira, браузер, Figma).
**Промптинг:** few-shot, chain-of-thought, системные промпты. Спецификации как промпты.
**Надзор:** выборочный. Рутину доверяете, архитектуру проверяете. TDD-подход.
**Автономность:** высокая. Агент сам разбивает задачу, реализует, тестирует, коммитит.

### Типичные проблемы

- **Один поток.** Один агент — одна задача. Параллельная работа с сохранением качества невозможна.
- **Ручная координация.** Frontend + backend + документация — переключаетесь вручную, теряете контекст.
- **Масштабирование.** На больших проектах (>100K строк, монорепо) контекстного окна не хватает.
- **Ручные процессы.** Код-ревью, CI/CD, слияние результатов — без автоматизации.

### Путь на следующий уровень

1. Работайте с несколькими агентами через git worktrees.
2. Внедряйте оркестрацию: генератор + ревьюер, иерархия агентов.
3. Автоматизируйте контроль: автотесты, линтеры, runbook, fail-until-done.

> **Пример:** Senior-разработчик через Claude Code с MCP для git, PostgreSQL и Jira — 10 минут ревью вместо 2 часов кодинга. Параллельная работа над 3 сервисами пока невозможна.

---

## Уровень 5: Менеджер параллельных агентов (оркестратор)

Вы управляете несколькими агентами параллельно. Ваша роль — архитектор и координатор. Агенты работают автономно, вы мониторите прогресс и принимаете решения.

**Инструменты:** параллельные агенты (git worktrees, docker, headless-режим). Оркестратор, runbook, мониторинг.
**Промптинг:** ролевая модель — агент-архитектор, агент-разработчик, агент-QA, агент-ревьюер. Runbook как промпт.
**Надзор:** стратегический. Логи и метрики. Вмешательство при зацикливании или конфликтах.
**Автономность:** очень высокая. Fail-until-done, hot-swap агентов. На выходе — готовый PR.

### Типичные проблемы

- **Конфликты.** Несколько агентов меняют связанный код — нужно разрешать конфликты.
- **Управление не масштабируется.** Ручное управление не работает. Нужна автоматизация.
- **Нет стандартов.** Каждая задача — runbook с нуля. Нет единой системы ролей и workflow.
- **Риски автономности.** Агент может создать PR с багом, который пройдёт тесты, но сломает продакшен.

### Путь дальше

Уровень 5 — не предел. Следующие шаги выходят за рамки курса:

1. **Архитектор автономных систем.** Фреймворки оркестрации, workflow как код, автоматическая валидация.
2. **Интеграция в SDLC.** ИИ-агенты как часть CI/CD. Автосоздание задач, реализация, тестирование, деплой.
3. **Исследования.** Эксперименты с новыми моделями и паттернами. Вклад в open-source.

> **Пример:** Tech lead управляет 7 микросервисами через флит агентов. Runbook → параллельная работа в worktrees → fail-until-done. Задача на 3 дня — за полдня.

---

> [Диаграмма: Навыки по уровням](./diagrams/skills-radar.md)

## Матрица навыков по уровням

<details>
<summary><b>Prompt Engineering</b></summary>

- **Level 1:** копирует примеры
- **Level 2:** адаптирует шаблоны
- **Level 3:** создаёт промпты с нуля
- **Level 4:** знает antipatterns, системные промпты
- **Level 5:** оптимизирует цепочки, знает edge cases

</details>

<details>
<summary><b>Работа с контекстом</b></summary>

- **Level 1:** не понимает лимиты
- **Level 2:** следит за размером
- **Level 3:** управляет осознанно
- **Level 4:** структурирует с XML, знает window sliding
- **Level 5:** продвинутые техники (RAG, сжатие)

</details>

<details>
<summary><b>Tool use</b></summary>

- **Level 1:** не использует
- **Level 2:** базовые команды (read, write)
- **Level 3:** интеграции с API
- **Level 4:** создаёт кастомные инструменты
- **Level 5:** MCP серверы, многоагентные системы

</details>

<details>
<summary><b>Debugging AI</b></summary>

- **Level 1:** не знает как
- **Level 2:** переформулирует
- **Level 3:** анализирует отказы, меняет стратегию
- **Level 4:** тестирует edge cases, знает ограничения
- **Level 5:** воспроизводит баги, знает внутренности

</details>

<details>
<summary><b>Автоматизация</b></summary>

- **Level 1:** вручную всё
- **Level 2:** копипаста в чат
- **Level 3:** скрипты с AI
- **Level 4:** CI/CD интеграции
- **Level 5:** агентные системы

</details>

<details>
<summary><b>Code review</b></summary>

- **Level 1:** принимает всё
- **Level 2:** проверяет синтаксис
- **Level 3:** оценивает архитектуру
- **Level 4:** выявляет security, performance
- **Level 5:** знает trade-offs, объясняет выбор AI

</details>

**Как оценить себя:** поставьте 1–5 по каждому навыку. Средний балл ≈ ваш уровень зрелости. Разброс > 2 между навыками — подтяните слабые зоны.

## Когда переходить на следующий уровень

Три признака готовности:

1. Навыки текущего уровня на 4–5 из 5
2. Можете объяснить коллеге технику следующего уровня
3. Разброс навыков не более 2 уровней

Не готовы, если понимаете "как", но не "почему". Или не можете воспроизвести результат осознанно.

---

[← Введение в курс](../module-0-intro/theory.md) | [Оглавление](../../README.md) | [8 уровней по Стиву Йегге →](02-yegge-levels.md)
