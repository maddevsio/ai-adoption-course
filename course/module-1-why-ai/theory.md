# Модель зрелости использования ИИ в разработке

## Введение: зачем эта модель?

Когда разработчики начинают использовать ИИ, они часто оказываются в замешательстве. ChatGPT даёт ответы на вопросы, Copilot подсказывает код, Cursor вообще сам пишет файлы. Какой инструмент правильный? Какие задачи можно делегировать, а какие опасно? Как понять, что вы движетесь в верном направлении, а не просто хаотично тыкаете кнопки?

Модель зрелости — это карта местности. Она показывает, где вы сейчас находитесь, куда можно двигаться дальше, и какие навыки нужны для перехода на следующий уровень. Это не абстрактная теория, а практическая рамка для самодиагностики и роста. Мы выделили 5 уровней владения ИИ-инструментами в разработке — от начинающего пользователя чата до менеджера параллельных агентов.

Эта модель построена на анализе реальных практик компаний и разработчиков. Каждый уровень описывает конкретные инструменты, паттерны работы, типичные проблемы и путь дальше. Никакого хайпа и футуризма — только то, что работает сегодня.

Зачем эта модель вам? Чтобы не застрять на уровне "спросил в чате — скопировал ответ". Чтобы понять, что копилот в IDE — это не предел. Чтобы увидеть, как разработчики уже сегодня делегируют агентам целые фичи, расширяют их возможности через **MCP** (Model Context Protocol — стандарт подключения внешних инструментов к агенту, подробнее в Модуле 6) и координируют несколько агентов параллельно. И чтобы осознанно выбирать, на каком уровне вам комфортно работать прямо сейчас, а к какому стоит стремиться.

## Уровень 1: Начальный пользователь (чат-помощник)

**Что это:** ИИ как улучшенная поисковая система. Вы заходите в ChatGPT, Gemini или DeepSeek, задаёте вопрос, получаете ответ, копируете код. Использование эпизодичное — когда застряли или не знаете, как что-то сделать.

### Характеристики

**Инструменты:** Браузерные чаты (ChatGPT, Gemini, DeepSeek). Бесплатные тиры или разовые запросы. Никакой интеграции в рабочий процесс.

**Промптинг:** Простые вопросы или просьбы в стиле "как сделать X?" или "напиши код для Y". Контекст почти не предоставляется — модель не знает ваш проект, стек, ограничения. Часто формулировка расплывчатая: "сделай лучше", "исправь это".

**Надзор:** Слабый или отсутствует. Код копируется "как есть", проверка сводится к "запустил — работает" или "запустил — не работает, пойду спрошу ещё раз". Интуиция о том, что ИИ может ошибаться, только формируется.

**Автономность:** Нулевая. ИИ не делает ничего сам — только отвечает на прямой запрос. Вы копируете результат вручную, вставляете в редактор, проверяете руками.

### Типичные проблемы

- **Слепое доверие:** Код от ИИ вставляется без понимания, что он делает. Может содержать уязвимости, устаревшие API, неоптимальные решения.
- **Отсутствие контекста:** ИИ не знает вашу кодовую базу, версии библиотек, стиль кода команды. Ответы общие и часто не подходят для реального проекта.
- **Повторяющиеся ошибки:** Один и тот же вопрос задаётся по-разному, потому что нет понимания, как сформулировать промпт, чтобы получить нужный результат с первого раза.
- **Неэффективность:** Копирование кода туда-сюда между браузером и IDE, потеря контекста между сессиями, невозможность переиспользовать результаты.

### Путь на следующий уровень

1. Начните проверять код от ИИ перед использованием: читайте его, тестируйте, ищите проблемы.
2. Учитесь формулировать запросы точнее: добавляйте контекст (язык, фреймворк, версии), примеры, критерии приёмки.
3. Интегрируйте ИИ в рабочий процесс: попробуйте IDE-копилот (GitHub Copilot, Codeium, Tabnine), чтобы не переключаться между браузером и редактором.

#### Переход на следующий уровень

**Объективные критерии:**
- [ ] Освоены все 6 навыков текущего уровня (оценка 4-5/5)
- [ ] Выполнено минимум 5 задач следующего уровня самостоятельно
- [ ] Можете объяснить коллеге технику из следующего уровня

**Не готовы к переходу, если:**
- Разброс навыков >2 уровней (Level 3 в промптах, но Level 1 в debugging)
- Не понимаете "почему" работает ваш подход (только "как")
- Не можете воспроизвести результат осознанно

### Пример разработчика на этом уровне

**Алексей, backend-разработчик на Python:** Раз в неделю открывает ChatGPT, когда не знает, как работать с новой библиотекой или забыл синтаксис. Копирует код из чата, вставляет в PyCharm, запускает. Если не работает — переформулирует вопрос, пробует ещё раз. Не проверяет код детально, считает, что "модель умнее меня в библиотеках". Недавно скопировал код для парсинга CSV, который падал на кириллице — потратил 2 часа на отладку, пока не понял, что модель дала пример для Python 2.

---

## Уровень 2: Интегрированный помощник (копилот в IDE)

**Что это:** ИИ встроен в среду разработки и работает постоянно. Вы видите автодополнения прямо в коде, принимаете или игнорируете их клавишей Tab. Развивается интуиция, когда стоит доверять подсказке, а когда игнорировать.

### Характеристики

**Инструменты:** IDE-копилоты: GitHub Copilot, Tabnine, Codeium, Supermaven. Расширения для VS Code, PyCharm, IntelliJ. Работают в фоне, предлагают код по мере набора.

**Промптинг:** Реактивный. Вы пишете комментарий или начинаете функцию — копилот предлагает продолжение. Промпты ограничены комментариями в коде и именами переменных/функций, которые служат "подсказками" для модели. Нет явного управления контекстом — модель видит открытые файлы.

**Надзор:** Растущий. Вы начинаете замечать, когда копилот даёт устаревший код или неправильные паттерны. Формируется "мышечная память" — автоматическое принятие хороших подсказок и игнорирование плохих. Но проверка всё ещё выборочная.

**Автономность:** Минимальная. Копилот предлагает — вы решаете. Он не пишет файлы целиком, не запускает команды, не меняет несколько мест одновременно. Только inline-автодополнение на уровне строк или блоков.

### Типичные проблемы

- **Реактивность вместо проактивности:** Вы реагируете на предложения копилота, а не ставите ему целенаправленные задачи. Инструмент используется для фрагментов, но не для решения целых задач.
- **Примитивный промптинг:** Промпты ограничены комментариями вроде "// функция для сортировки пользователей". Нет понимания, как дать модели больше контекста или примеров.
- **Ограниченный масштаб:** Копилот помогает написать метод или класс, но не может провести рефакторинг модуля, написать интеграционные тесты или реализовать целую фичу. Для этого нужны другие инструменты.
- **Зависимость от открытых файлов:** Модель видит только то, что открыто в редакторе. Если нужный контекст в другом файле — копилот не знает о нём и даёт неполные ответы.

### Путь на следующий уровень

1. Переходите от автодополнения к явным командам: используйте Copilot Chat или аналоги для постановки задач ("напиши тесты для этого модуля", "отрефактори метод").
2. Экспериментируйте с агентными инструментами: попробуйте Cursor в Agent mode, Claude Code, Windsurf. Научитесь делегировать не фрагменты, а целые задачи.
3. Изучайте промпт-инжиниринг: добавляйте примеры (few-shot), структурируйте задачи пошагово, задавайте роли и формат вывода.

#### Переход на следующий уровень

**Объективные критерии:**
- [ ] Освоены все 6 навыков текущего уровня (оценка 4-5/5)
- [ ] Выполнено минимум 5 задач следующего уровня самостоятельно
- [ ] Можете объяснить коллеге технику из следующего уровня

**Не готовы к переходу, если:**
- Разброс навыков >2 уровней (Level 3 в промптах, но Level 1 в debugging)
- Не понимаете "почему" работает ваш подход (только "как")
- Не можете воспроизвести результат осознанно

### Пример разработчика на этом уровне

**Мария, frontend-разработчик на React:** Работает с GitHub Copilot включённым постоянно. Пишет комментарий "// компонент кнопки с иконкой и текстом" — копилот предлагает JSX, она нажимает Tab. Написание рутинных компонентов ускорилось вдвое. Но когда нужно провести рефакторинг большого модуля или написать сложные интеграционные тесты, копилот не помогает — только отдельные куски. Пыталась сформулировать более сложную задачу через Copilot Chat, но не всегда получает нужный результат, потому что промпт недостаточно чёткий.

---

## Уровень 3: Активный экспериментатор (драйвер агента)

**Что это:** Вы осознанно выбираете агентные инструменты и делегируете им целые задачи, а не фрагменты. Агент читает файлы, пишет код, запускает команды, итерирует. Ваша роль — постановщик задач, проверяющий и корректирующий результат.

> **AGENTS.md** (файл с правилами работы агента, создадим в Модуле 4) — это "конституция" вашего проекта, которую агент читает перед началом работы.

### Характеристики

**Инструменты:** AI-IDE и CLI-агенты: Cursor (Agent mode), Windsurf, Claude Code, Aider, OpenCode. Агент работает с файловой системой, git, terminal. Вы ставите задачу текстом или голосом — агент выполняет.

**Промптинг:** Задачи вместо вопросов. "Напиши функцию X с такими параметрами, покрой её тестами, проверь линтером" вместо "как написать функцию X?". Появляется структура промпта: контекст (что уже есть в проекте) → задача (что нужно сделать) → критерии приёмки (как проверить). Формируется библиотека эффективных промптов для повседневных задач.

**Надзор:** Активный и постоянный. Вы проверяете каждый шаг агента: какие файлы он читал, что написал, какие команды запустил. Знаете, когда агент может "сойти с рельсов" (длинные сессии, сложная бизнес-логика, отсутствие тестов). Понимаете, что агент — это мощный джуниор, которому нужен надзор.

**Автономность:** Средняя. Агент выполняет задачу от начала до конца: читает требования, анализирует код, пишет решение, запускает тесты, коммитит. Но работает под вашим контролем — вы можем остановить его, скорректировать направление, попросить переделать.

### Типичные проблемы

- **Одна задача за раз:** Агент работает последовательно. Вы не можете запустить несколько агентов параллельно на разные подзадачи — контекст путается, файлы конфликтуют.
- **Потеря фокуса в длинных сессиях:** Если задача сложная или агент долго итерирует, контекст "размывается". Агент начинает предлагать решения, не связанные с исходной задачей, или забывает критерии приёмки.
- **Сложность с архитектурными задачами:** Агент хорош в реализации по спецификации, но плох в проектировании архитектуры с нуля. Вам приходится самим разбивать большую фичу на подзадачи и ставить каждую отдельно.
- **Ручной контроль качества:** Проверка результата, запуск тестов, слияние веток — всё это делаете вы. Автоматизации пока нет.

### Путь на следующий уровень

1. Научитесь писать спецификации: формализуйте требования к задачам в виде документов (планы фичей, ADR), чтобы агент работал автономнее.
2. Управляйте контекстом: создавайте артефакты проекта (**Constitution** — набор правил и принципов работы агента, определяющих что можно и нельзя делать, подробнее в Модуле 5; memory, guidelines), которые агент может переиспользовать между сессиями.
3. Расширяйте агента: установите MCP-серверы, чтобы агент мог ходить в Jira, БД, браузер, Figma — не только в файловую систему.

#### Переход на следующий уровень

**Объективные критерии:**
- [ ] Освоены все 6 навыков текущего уровня (оценка 4-5/5)
- [ ] Выполнено минимум 5 задач следующего уровня самостоятельно
- [ ] Можете объяснить коллеге технику из следующего уровня

**Не готовы к переходу, если:**
- Разброс навыков >2 уровней (Level 3 в промптах, но Level 1 в debugging)
- Не понимаете "почему" работает ваш подход (только "как")
- Не можете воспроизвести результат осознанно

### Пример разработчика на этом уровне

**Дмитрий, fullstack-разработчик на Node.js:** Использует Claude Code для большинства задач. Утром открывает проект, формулирует задачу: "Реализуй endpoint /api/users/:id/orders, который возвращает все заказы пользователя с пагинацией. Используй существующие модели User и Order. Покрой код тестами через Jest. Проверь ESLint." Агент читает код, пишет endpoint, тесты, запускает проверки. Дмитрий ревьюит результат, находит баг в обработке несуществующего пользователя, корректирует промпт: "Добавь обработку случая, когда user не найден — верни 404". Агент исправляет. Задача закрыта за 15 минут вместо часа. Но когда нужно рефакторить архитектуру всего API-слоя, Дмитрий работает сам — агент не справляется с таким масштабом.

---

## Уровень 4: Специалист по одному агенту (мастер SDD и MCP)

**Что это:** Вы используете одного мощного агента как основной интерфейс для разработки, расширив его возможности через **MCP** (Model Context Protocol — стандарт подключения внешних инструментов к агенту, подробнее в Модуле 6) и выстроив процесс на основе спецификаций. Агент работает автономнее, потому что вы даёте ему чёткие правила, примеры и инструменты.

### Характеристики

**Инструменты:** Один основной CLI или IDE-агент (Claude Code, Cursor, Windsurf) + набор MCP-серверов (git, БД, Jira, браузер, Figma). Агент умеет не только писать код, но и ходить в внешние системы, читать задачи из трекера, проверять данные в БД, искать информацию в интернете.

**Промптинг:** Продвинутый. Few-shot промптинг (даёте примеры желаемого результата), chain-of-thought (просите агента думать пошагово), системные промпты (задаёте роль и формат вывода). Спецификации как промпты: вместо "сделай фичу X" даёте агенту документ с требованиями, архитектурой, примерами, критериями приёмки. Агент читает спецификацию и реализует.

**Надзор:** Выборочный. Вы доверяете агенту рутинные задачи с чёткими правилами (CRUD, рефакторинг, тесты), но проверяете архитектурные решения и бизнес-логику. Используете TDD-подход: агент пишет код → автоматически запускаются тесты → агент видит ошибки и исправляет. Человек вмешивается только когда агент зациклился или выбрал неверное направление.

**Автономность:** Высокая. Агент выполняет комплексные задачи на уровне модуля или фичи: "Реализуй сервис аутентификации на FastAPI с JWT, учитывая наши существующие модели User и Session". Агент сам разбивает задачу на подзадачи, реализует, тестирует, коммитит. Вы проверяете результат постфактум.

### Типичные проблемы

- **Пропускная способность:** Производительность ограничена скоростью и контекстным окном одного агента. Вы не можете параллельно вести несколько потоков работ без потери качества.
- **Ручная координация:** Если у вас несколько независимых задач (frontend фича + backend фича + документация), приходится переключаться между ними вручную, теряя контекст.
- **Масштабирование:** На больших проектах (>100K строк кода, монорепо) агент начинает "задыхаться" — контекстное окно не вмещает всю кодовую базу, приходится тщательно фильтровать файлы.
- **Автоматизация процессов:** Код-ревью, запуск CI/CD, слияние результатов от агента в основную ветку — всё это требует ручных усилий. Нет единой системы управления несколькими агентами.

### Путь на следующий уровень

1. Научитесь работать с несколькими агентами параллельно: используйте git worktrees для изоляции контекстов, запускайте разные агенты на разные подзадачи одновременно.
2. Внедрите паттерны оркестрации: генератор + ревьюер, декомпозиция задач, иерархия агентов (координатор → исполнители).
3. Автоматизируйте контроль качества: настройте автоматический запуск тестов и линтеров, создайте runbook для стандартных задач, используйте fail-until-done подход (агент работает, пока тесты не пройдут).

#### Переход на следующий уровень

**Объективные критерии:**
- [ ] Освоены все 6 навыков текущего уровня (оценка 4-5/5)
- [ ] Выполнено минимум 5 задач следующего уровня самостоятельно
- [ ] Можете объяснить коллеге технику из следующего уровня

**Не готовы к переходу, если:**
- Разброс навыков >2 уровней (Level 3 в промптах, но Level 1 в debugging)
- Не понимаете "почему" работает ваш подход (только "как")
- Не можете воспроизвести результат осознанно

### Пример разработчика на этом уровне

**Елена, senior backend-разработчик на Go:** Работает через Claude Code с настроенными MCP-серверами для git, PostgreSQL и Jira. Утром открывает задачу в Jira, копирует ID. Ставит агенту задачу: "Реализуй фичу PROJ-1234. Прочитай описание из Jira, проверь схему БД через MCP, реализуй API по нашей конституции (AGENTS.md), покрой тестами, убедись что линтер проходит." Агент читает задачу из Jira, анализирует схему БД, пишет код, тесты, прогоняет golangci-lint, создаёт PR. Елена тратит 10 минут на ревью вместо 2 часов на реализацию. Но когда нужно одновременно реализовать 3 микросервиса для большой фичи, Елена делает их последовательно — параллельная работа с одним агентом невозможна, контекст путается.

---

## Уровень 5: Менеджер параллельных агентов (оркестратор)

**Что это:** Вы управляете несколькими агентами параллельно, распределяя между ними разные аспекты одной большой задачи или независимые задачи. Ваша роль — архитектор и координатор, а не кодер. Агенты работают автономно, вы мониторите прогресс и принимаете финальные решения.

### Характеристики

**Инструменты:** Несколько параллельных агентов (через git worktrees, docker контейнеры, headless-режим Claude Code, или платформы вроде OpenClaw). Оркестратор, который распределяет задачи и собирает результаты. Runbook — формализованный план работы. Системы мониторинга (логи агентов, heartbeat, метрики токенов).

**Промптинг:** Ролевая модель. Агент-архитектор планирует задачи, агент-разработчик реализует код (дешёвая модель), агент-QA проверяет тесты, агент-ревьюер проводит код-ревью (умная модель). Каждая роль — своя модель, свои инструменты, свой уровень автономности. Промпты структурированы как runbook: цель → подзадачи → кому какая → порядок → критерии приёмки → как сливать результаты.

**Надзор:** Стратегический. Вы не контролируете каждый шаг каждого агента — только мониторите прогресс через логи и метрики. Вмешиваетесь, когда агент зациклился (fail-until-done механизм), когда результаты агентов конфликтуют (разрешение конфликтов), или когда задача завершена (финальная приёмка). Агенты работают автономно внутри своих зон ответственности.

**Автономность:** Очень высокая. Агенты выполняют задачи от начала до конца без вашего участия. Fail-until-done: агент работает в цикле Do → Check (тесты/линтер) → Fix, пока тесты не пройдут. Hot-swap: если агент зациклился или провайдер недоступен, система автоматически переключается на другого агента. Вы получаете готовый PR, который только нужно проревьюить и влить.

### Типичные проблемы

- **Координация и конфликты:** Когда несколько агентов меняют связанные части кода, возникают конфликты. Их разрешение требует понимания, что сделал каждый агент и как объединить результаты.
- **Масштабируемость управления:** С ростом числа агентов и задач ручное управление становится неэффективным. Нужна автоматизация распределения задач, мониторинга, сборки результатов.
- **Отсутствие стандартов:** Каждая задача требует написания runbook с нуля. Нет единой системы для описания ролей, workflow, критериев приёмки — всё делается ad-hoc.
- **Риски автономности:** Агент может автоматически создать PR с багом, который пройдёт все тесты (если тесты неполные), но сломает продакшен. Финальная ответственность за результат всё равно на вас.

### Путь дальше

Уровень 5 — это не предел, но следующие шаги выходят за рамки курса:

1. **Архитектор автономных систем:** Использование фреймворков оркестрации (LangChain, AutoGPT, кастомные скрипты). Проектирование workflow как кода. Автоматическая валидация результатов. Построение отказоустойчивых систем, где сбой одного агента не ломает весь процесс.
2. **Интеграция в SDLC компании:** ИИ-агенты как часть CI/CD пайплайна. Автоматическое создание задач, реализация, тестирование, код-ревью, деплой. Метрики качества работы агентов. Управление бюджетом и стоимостью токенов на уровне команды или компании.
3. **Исследовательская работа:** Эксперименты с новыми моделями, паттернами, архитектурами. Вклад в open-source инструменты для агентной разработки. Публикация практик и уроков.

### Пример разработчика на этом уровне

**Игорь, tech lead в стартапе:** Управляет разработкой платформы из 7 микросервисов на Go через флит агентов (концепция, демонстрируемая в учебном проекте **Enji Fleet** от Mad Devs). Утром Игорь получает задачу от продакта: "Добавить экспорт отчётов в PDF для модуля аналитики". Игорь пишет runbook: декомпозирует задачу на подзадачи (1. API endpoint, 2. PDF-генератор, 3. Тесты, 4. Документация), назначает каждую подзадачу агенту через платформу. Агент-архитектор читает конституцию проекта, планирует архитектуру. Три агента-разработчика параллельно реализуют код в изолированных git worktrees. Агент-QA пишет интеграционные тесты. Агент-ревьюер проверяет код, находит проблемы, возвращает на доработку. Fail-until-done механизм гарантирует, что агенты не остановятся, пока тесты не пройдут. Через 4 часа Игорь получает 4 готовых PR с Telegram-уведомлением. Он тратит 30 минут на финальное ревью, вливает ветки, деплоит в staging. Задача, которая заняла бы 3 дня работы команды из 3 разработчиков, закрыта за полдня силами одного человека и флита агентов.

---

### Матрица навыков по уровням

| Навык | Level 1 | Level 2 | Level 3 | Level 4 | Level 5 |
|-------|---------|---------|---------|---------|---------|
| **Prompt Engineering** | Копирует примеры | Адаптирует шаблоны | Создаёт эффективные промпты с нуля | Знает antipatterns, системные промпты | Оптимизирует цепочки, знает edge cases |
| **Работа с контекстом** | Не понимает лимиты | Следит за размером | Управляет контекстом осознанно | Структурирует с XML, знает window sliding | Продвинутые техники (RAG, сжатие) |
| **Tool use** | Не использует | Базовые команды (read, write) | Интеграции с API | Создаёт кастомные инструменты | MCP серверы, многоагентные системы |
| **Debugging AI** | Не знает как | Переформулирует | Анализирует отказы, меняет стратегию | Тестирует edge cases, знает ограничения | Воспроизводит баги, знает внутренности |
| **Автоматизация** | Вручную всё | Копипаста в чат | Скрипты с AI | CI/CD интеграции | Агентные системы с autonomy |
| **Code review** | Принимает всё | Проверяет синтаксис | Оценивает архитектуру | Выявляет security, performance | Знает trade-offs, может объяснить AI выбор |

**Как пользоваться:**
- Оцените себя честно по каждому навыку (1-5)
- Средний балл ≈ ваш уровень зрелости
- Разброс >2 между навыками → нужно выровнять слабые зоны

---

## Самодиагностика: определите свой уровень

Ответьте на вопросы ниже и подсчитайте баллы, чтобы понять, на каком уровне зрелости вы находитесь сейчас.

### Вопросы

**1. Какие ИИ-инструменты вы используете в работе?**
- A) Только браузерные чаты (ChatGPT, Gemini) — 1 балл
- B) IDE-копилот (GitHub Copilot, Tabnine, Codeium) — 2 балла
- C) Агентные инструменты (Cursor, Claude Code, Windsurf) — 3 балла
- D) Агент + MCP-серверы для расширения возможностей — 4 балла
- E) Несколько агентов параллельно + оркестрация — 5 баллов

**2. Как часто вы используете ИИ при разработке?**
- A) Эпизодически, когда застрял — 1 балл
- B) Каждый день, копилот включён постоянно — 2 балла
- C) Несколько раз в день для конкретных задач (фича, рефакторинг, тесты) — 3 балла
- D) ИИ — основной интерфейс для большинства задач — 4 балла
- E) Вся разработка идёт через агентов, я координирую процесс — 5 баллов

**3. Как вы формулируете запросы к ИИ?**
- A) Простые вопросы: "как сделать X?" — 1 балл
- B) Комментарии и имена переменных как подсказки для копилота — 2 балла
- C) Задачи с контекстом и критериями: "реализуй X, используя Y, покрой тестами" — 3 балла
- D) Спецификации и примеры: few-shot, chain-of-thought, системные промпты — 4 балла
- E) Runbook для нескольких агентов: роли, подзадачи, порядок, критерии — 5 баллов

**4. Как вы проверяете результаты от ИИ?**
- A) Запустил — работает? Ок, копирую — 1 балл
- B) Читаю код, иногда тестирую, замечаю очевидные ошибки — 2 балла
- C) Всегда проверяю перед коммитом: тесты, линтер, логика — 3 балла
- D) Автоматические проверки: TDD-подход, агент сам запускает тесты и исправляет ошибки — 4 балла
- E) Fail-until-done: агент работает, пока тесты не пройдут, я только принимаю финальный результат — 5 баллов

**5. Можете ли вы привести пример, когда ИИ выдал вам неправильный код?**
- A) Не помню такого (= не проверяю) — 1 балл
- B) Да, но не понял почему — просто переспросил — 1 балл
- C) Да, нашёл ошибку при проверке, исправил вручную — 2 балла
- D) Да, проанализировал почему модель ошибась, скорректировал промпт — 3 балла
- E) Да, внедрил автоматические проверки, чтобы такое не повторялось — 4 балла

### Ключ подсчёта

Сложите баллы по всем вопросам:

- **5-7 баллов:** Уровень 1 — Начальный пользователь
- **8-11 баллов:** Уровень 2 — Интегрированный помощник
- **12-15 баллов:** Уровень 3 — Активный экспериментатор
- **16-19 баллов:** Уровень 4 — Специалист по одному агенту
- **20-25 баллов:** Уровень 5 — Менеджер параллельных агентов

Эта оценка — не абсолютная истина, а ориентир. Возможно, в разных аспектах вы находитесь на разных уровнях (например, промптинг уровня 3, но инструменты уровня 2). Это нормально. Модель зрелости показывает направление роста, а не жёсткие границы.

### Интерпретация результатов

**35-40 баллов (Level 4-5):** Вы эксперт. Можете обучать других, создавать агентные системы. Фокус на edge cases и оптимизации.

**25-34 балла (Level 3):** Уверенный пользователь. Знаете лучшие практики. Следующий шаг: автоматизация и глубокое понимание ограничений.

**15-24 балла (Level 2):** Практикующий. Умеете адаптировать готовые решения. Фокус: системность и debugging.

**8-14 баллов (Level 1):** Новичок. Ничего страшного! Пройдите курс полностью и практикуйте ежедневно 2-4 недели.

**Дисбаланс навыков (разброс >10 баллов):**
- Если сильны в промптах, но слабы в tools → модули 6-7 (MCP, оркестрация)
- Если сильны в code review, но слабы в автоматизации → модуль 4 (agents)
- Если сильны в debugging, но слабы в контексте → модуль 3 (prompting)

---

## Путь роста: как курс ведёт вас с уровня 1 до 5

Курс построен так, чтобы вести вас последовательно через все уровни зрелости. Каждый модуль отвечает за конкретный переход или закрепление навыков текущего уровня.

### Часть I: Фундамент (модули 1-3) — с уровня 1-2 до уровня 3

**Модуль 1: Зачем разработчику ИИ**
- Откалибровать ожидания: ИИ — не замена программиста, а инструмент для роста абстракции
- Понять модель зрелости и определить свой текущий уровень
- Увидеть реальные кейсы: где агенты работают, где нет, какие метрики достижимы

**Модуль 2: Инструменты + установка**
- Перейти от браузерных чатов к интегрированным инструментам
- Установить Claude Code CLI — ваш первый агентный инструмент
- Понять категории инструментов и научиться выбирать под задачу

**Модуль 3: Промптинг**
- Научиться формулировать задачи, а не вопросы
- Освоить структуру промпта: контекст → задача → критерии приёмки
- Применять техники промптинга для разных типов задач (код, тесты, рефакторинг)

**Результат:** Вы переходите с уровня 1 (чат-помощник) или 2 (копилот) на уровень 3 (драйвер агента). Умеете ставить агенту задачи и проверять результаты.

### Часть II: Агентная разработка (модули 4-5) — с уровня 3 до уровня 4

**Модуль 4: Работа с AI-агентом**
- Делегировать агенту целые задачи: от постановки до реализации
- Настроить правила работы агента через AGENTS.md
- Понять цикл агента: plan → act → observe → adjust
- Освоить надзор: когда вмешиваться, как корректировать

**Модуль 5: Spec-driven development и управление контекстом**
- Писать спецификации, по которым агент работает автономно
- Управлять контекстом через артефакты: конституция, планы фичей, заметки
- Версионировать промпты и результаты для повторяемости
- Использовать Skills — готовые промпты для типовых задач

**Результат:** Вы переходите с уровня 3 (драйвер агента) на уровень 4 (специалист по одному агенту). Агент работает автономнее, потому что вы даёте ему чёткие спецификации и управляете контекстом.

### Часть III: Расширение и оркестрация (модули 6-7) — с уровня 4 до уровня 5

**Модуль 6: MCP — настройка и использование**
- Расширить возможности агента через MCP-серверы (git, БД, Jira, браузер)
- Настроить интеграции, чтобы агент мог ходить во внешние системы
- Решать задачи, требующие данных за пределами файловой системы

**Модуль 7: Параллельные агенты и оркестрация**
- Управлять несколькими агентами одновременно через git worktrees
- Применять паттерны оркестрации: генератор + ревьюер, декомпозиция, иерархия
- Писать runbook для распределения задач между агентами
- Настроить fail-until-done и hot-swap для автономной работы
- Освоить Ralph Loop — цикл агентной работы: plan → implement → test → review → iterate, где агент не останавливается, пока все тесты не пройдут

**Результат:** Вы переходите с уровня 4 (специалист по одному агенту) на уровень 5 (менеджер параллельных агентов). Ваша роль смещается от кодинга к координации и архитектуре.

### Часть IV: Ответственность (модуль 8) — для всех уровней

**Модуль 8: Ответственное использование ИИ**
- Знать ограничения ИИ и границы делегирования на каждом уровне
- Настроить безопасность: изоляция, sandboxing, контроль данных
- Понять принцип "доверяй, но проверяй" и как ответственность растёт с автономностью
- Пройти финальную самодиагностику и сравнить результаты с началом курса

**Результат:** Вы понимаете риски и границы на любом уровне зрелости. Знаете, что можно делегировать безопасно, а что требует человеческого контроля.

---

## Заключение

Модель зрелости — это не гонка к уровню 5. Это карта, которая помогает понять, где вы находитесь и куда можете двигаться. Для многих задач и проектов уровня 3 или 4 вполне достаточно. Уровень 5 нужен, когда вы управляете большой кодовой базой, множеством параллельных задач или строите платформу с автономными агентами.

Главное — осознанный выбор. Вы выбираете уровень, который соответствует вашим задачам, команде, проекту. ИИ-инструменты дают вам возможность работать на несколько уровней абстракции выше, чем раньше. Как компилятор освободил программистов от написания ассемблера, так агенты освобождают от рутинного кодинга. Но финальная ответственность, архитектура, решения — остаются за человеком.

Курс даст вам инструменты, практики и понимание для роста с уровня 1 до уровня 5. Дальше — ваш выбор, насколько глубоко вы хотите интегрировать ИИ в свой рабочий процесс.
