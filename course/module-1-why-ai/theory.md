# Уровни зрелости использования ИИ в разработке

> [Диаграмма: 5 уровней зрелости](./diagrams/maturity-levels.md)

## Уровень 1: Начинающий (чат-помощник)

**Что это:** ИИ как улучшенная поисковая система. Вы заходите в ChatGPT, Gemini или DeepSeek, задаёте вопрос, получаете ответ, копируете код. Использование эпизодичное — когда застряли или не знаете, как что-то сделать.

### Характеристики

**Инструменты:** Браузерные чаты (ChatGPT, Gemini, DeepSeek). Разовые запросы. Никакой интеграции в рабочий процесс.

**Промптинг:** Простые вопросы или просьбы в стиле "как сделать X?" или "напиши код для Y". Контекст почти не предоставляется — модель не знает ваш проект, стек, ограничения. Часто формулировка расплывчатая: "сделай лучше", "исправь это".

**Надзор:** Слабый или отсутствует. Код копируется "как есть", проверка сводится к "запустил — работает" или "запустил — не работает, пойду спрошу ещё раз". Интуиция о том, что ИИ может ошибаться, только формируется.

**Автономность:** Нулевая. ИИ не делает ничего сам — только отвечает на прямой запрос. Вы копируете результат вручную, вставляете в редактор, проверяете руками.

### Типичные проблемы

- **Слепое доверие:** Код от ИИ вставляется без понимания, что он делает. Может содержать уязвимости, устаревшие API, неоптимальные решения.
- **Отсутствие контекста:** ИИ не знает вашу кодовую базу, версии библиотек, стиль кода команды. Ответы общие и часто не подходят для реального проекта.
- **Повторяющиеся ошибки:** Один и тот же вопрос задаётся по-разному, потому что нет понимания, как сформулировать промпт, чтобы получить нужный результат с первого раза.
- **Неэффективность:** Копирование кода туда-сюда между браузером и IDE, потеря контекста между сессиями, невозможность переиспользовать результаты.

### Путь на следующий уровень

1. Начните проверять код от ИИ перед использованием: читайте его, тестируйте, ищите проблемы.
2. Учитесь формулировать запросы точнее: добавляйте контекст (язык, фреймворк, версии), примеры, критерии приёмки.
3. Интегрируйте ИИ в рабочий процесс: попробуйте IDE-копилот (GitHub Copilot, Tabnine), чтобы не переключаться между браузером и редактором.

#### Переход на следующий уровень

**Объективные критерии:**
- [ ] Освоены все навыки текущего уровня (оценка 4-5/5)
- [ ] Можете объяснить коллеге технику из следующего уровня

**Не готовы к переходу, если:**
- Разброс навыков >2 уровней (Level 3 в промптах, но Level 1 в debugging)
- Не понимаете "почему" работает ваш подход (только "как")
- Не можете воспроизвести результат осознанно

### Пример разработчика на этом уровне

**Алексей, backend-разработчик на Python:** Раз в неделю открывает ChatGPT, когда не знает, как работать с новой библиотекой или забыл синтаксис. Копирует код из чата, вставляет в PyCharm, запускает. Если не работает — переформулирует вопрос, пробует ещё раз. Не проверяет код детально, считает, что "модель умнее меня в библиотеках". Недавно скопировал код для парсинга CSV, который падал на кириллице — потратил 2 часа на отладку, пока не понял, что модель дала пример для устаревшей версии Python.

---

## Уровень 2: Интегрированный помощник (копилот в IDE)

**Что это:** ИИ встроен в среду разработки и работает постоянно. Вы видите автодополнения прямо в коде. Развивается интуиция, когда стоит доверять подсказке, а когда игнорировать.

### Характеристики

**Инструменты:** IDE-копилоты: GitHub Copilot, Tabnine. Расширения для VS Code, PyCharm, IntelliJ. Работают в фоне, предлагают код по мере набора.

**Промптинг:** Реактивный. Вы пишете комментарий или начинаете функцию — копилот предлагает продолжение. Промпты ограничены комментариями в коде и именами переменных/функций, которые служат "подсказками" для модели. Нет явного управления контекстом — модель видит открытые файлы.

**Надзор:** Растущий. Вы начинаете замечать, когда копилот даёт устаревший код или неправильные паттерны. Но проверка всё ещё выборочная.

**Автономность:** Минимальная. Копилот предлагает — вы решаете. Он не пишет файлы целиком, не запускает команды, не меняет несколько мест одновременно. Только inline-автодополнение на уровне строк или блоков.

### Типичные проблемы

- **Реактивность вместо проактивности:** Вы реагируете на предложения копилота, а не ставите ему целенаправленные задачи. Инструмент используется для фрагментов, но не для решения целых задач.
- **Примитивный промптинг:** Промпты ограничены комментариями вроде "// функция для сортировки пользователей". Нет понимания, как дать модели больше контекста или примеров.
- **Ограниченный масштаб:** Копилот помогает написать метод или класс, но не может провести рефакторинг модуля, написать интеграционные тесты или реализовать целую фичу. Для этого нужны другие инструменты.
- **Зависимость от открытых файлов:** Модель видит только то, что открыто в редакторе. Если нужный контекст в другом файле — копилот не знает о нём и даёт неполные ответы.

### Путь на следующий уровень

1. Переходите от автодополнения к явным командам: используйте Copilot Chat или аналоги для постановки задач ("напиши тесты для этого модуля", "отрефактори метод").
2. Экспериментируйте с агентными инструментами: попробуйте Cursor в Agent mode, Claude Code, Antigravity. Научитесь делегировать не фрагменты, а целые задачи.
3. Изучайте промпт-инжиниринг: добавляйте примеры (few-shot), структурируйте задачи пошагово, задавайте роли и формат вывода.

#### Переход на следующий уровень

**Объективные критерии:**
- [ ] Освоены все навыки текущего уровня (оценка 4-5/5)
- [ ] Можете объяснить коллеге технику из следующего уровня

**Не готовы к переходу, если:**
- Разброс навыков >2 уровней (Level 3 в промптах, но Level 1 в debugging)
- Не понимаете "почему" работает ваш подход (только "как")
- Не можете воспроизвести результат осознанно

### Пример разработчика на этом уровне

**Айтмырза, frontend-разработчик на React:** Работает с GitHub Copilot включённым постоянно. Пишет комментарий "// компонент кнопки с иконкой и текстом" — копилот предлагает JSX, она нажимает Tab. Написание рутинных компонентов ускорилось вдвое. Но когда нужно провести рефакторинг большого модуля или написать сложные интеграционные тесты, копилот не помогает — только отдельные куски. Пытался сформулировать более сложную задачу через Copilot Chat, но не всегда получает нужный результат, потому что промпт недостаточно чёткий.

---

## Уровень 3: Agentic developer

**Что это:** Вы осознанно выбираете агентные инструменты и делегируете им целые задачи, а не фрагменты. Агент читает файлы, пишет код, запускает команды, итерирует. Ваша роль — постановщик задач, проверяющий и корректирующий результат.

> **AGENTS.md** (файл с правилами работы агента, создадим в Модуле 4) — это "конституция" вашего проекта, которую агент читает перед началом работы.

### Характеристики

**Инструменты:** AI-IDE и CLI-агенты: Cursor (Agent mode), Claude Code, Antigravity, OpenCode. Агент работает с файловой системой, git, terminal. Вы ставите задачу текстом или голосом — агент выполняет.

**Промптинг:** Задачи вместо вопросов. "Напиши функцию X с такими параметрами, покрой её тестами, проверь линтером" вместо "как написать функцию X?". Появляется структура промпта: контекст (что уже есть в проекте) → задача (что нужно сделать) → критерии приёмки (как проверить). Формируется библиотека эффективных промптов для повседневных задач.

**Надзор:** Активный. Вы проверяете результаты труда агента: какие файлы он читал, что написал, какие команды запустил. Знаете, когда агент может "сойти с рельсов" (длинные сессии, сложная бизнес-логика, отсутствие тестов). Понимаете, что агент — это мощный джуниор, которому нужен надзор.

**Автономность:** Средняя. Агент выполняет задачу от начала до конца: читает требования, анализирует код, пишет решение, запускает тесты, коммитит. Но работает под вашим контролем — вы можете остановить его, скорректировать направление, попросить переделать.

### Типичные проблемы

- **Одна задача за раз:** Агент работает последовательно. Вы не можете запустить несколько агентов параллельно на разные подзадачи — контекст путается, файлы конфликтуют.
- **Потеря фокуса в длинных сессиях:** Если задача сложная или агент долго итерирует, контекст "размывается". Агент начинает предлагать решения, не связанные с исходной задачей, или забывает критерии приёмки.
- **Сложность с архитектурными задачами:** Агент хорош в реализации по спецификации, но плох в проектировании архитектуры с нуля. Вам приходится самим разбивать большую фичу на подзадачи и ставить каждую отдельно.
- **Ручной контроль качества:** Проверка результата, запуск тестов, слияние веток — всё это делаете вы. Автоматизации пока нет.

### Путь на следующий уровень

1. Научитесь писать спецификации: формализуйте требования к задачам в виде документов (планы фичей, ADR), чтобы агент работал автономнее.
2. Управляйте контекстом: создавайте артефакты проекта (**Constitution** — набор правил и принципов работы агента, определяющих что можно и нельзя делать, подробнее в Модуле 5; memory, guidelines), которые агент может переиспользовать между сессиями.
3. Расширяйте агента: установите MCP-серверы, чтобы агент мог ходить в Jira, БД, браузер, Figma — не только в файловую систему.

#### Переход на следующий уровень

**Объективные критерии:**
- [ ] Освоены все навыки текущего уровня (оценка 4-5/5)
- [ ] Можете объяснить коллеге технику из следующего уровня

**Не готовы к переходу, если:**
- Разброс навыков >2 уровней (Level 3 в промптах, но Level 1 в debugging)
- Не понимаете "почему" работает ваш подход (только "как")
- Не можете воспроизвести результат осознанно

### Пример разработчика на этом уровне

**Айгуль, fullstack-разработчик на Node.js:** Использует Claude Code для большинства задач. Утром открывает проект, формулирует задачу: "Реализуй endpoint /api/users/:id/orders, который возвращает все заказы пользователя с пагинацией. Используй существующие модели User и Order. Покрой код тестами через Jest. Проверь ESLint." Агент читает код, пишет endpoint, тесты, запускает проверки. Айгуль ревьюит результат, находит баг в обработке несуществующего пользователя, корректирует промпт: "Добавь обработку случая, когда user не найден — верни 404". Агент исправляет. Затем Айгуль проводит ручное тестирование, удостоверится, что все выполнено верно. Задача закрыта за 15 минут вместо часа. Но когда нужно рефакторить архитектуру всего API-слоя, Айгуль работает сама — агент не справляется с таким масштабом.

---

## Уровень 4: Продвинутый Agentic developer

**Что это:** Вы используете одного мощного агента как основной интерфейс для разработки, расширив его возможности через **MCP** (Model Context Protocol — стандарт подключения внешних инструментов к агенту, подробнее в Модуле 6) и выстроив процесс на основе спецификаций. Агент работает автономнее, потому что вы даёте ему чёткие правила, примеры и инструменты.

### Характеристики

**Инструменты:** Один основной CLI или IDE-агент (Claude Code, Cursor, Antigravity) + набор MCP-серверов (git, БД, Jira, браузер, Figma). Агент умеет не только писать код, но и ходить в внешние системы, читать задачи из трекера, проверять данные в БД, искать информацию в интернете.

**Промптинг:** Продвинутый. Few-shot промптинг (даёте примеры желаемого результата), chain-of-thought (просите агента думать пошагово), системные промпты (задаёте роль и формат вывода). Спецификации как промпты: вместо "сделай фичу X" даёте агенту документ с требованиями, архитектурой, примерами, критериями приёмки. Агент читает спецификацию и реализует.

**Надзор:** Выборочный. Вы доверяете агенту рутинные задачи с чёткими правилами (CRUD, рефакторинг, тесты), но проверяете архитектурные решения и бизнес-логику. Используете TDD-подход: агент пишет код → автоматически запускаются тесты → агент видит ошибки и исправляет. Человек вмешивается только когда агент зациклился или выбрал неверное направление.

**Автономность:** Высокая. Агент выполняет комплексные задачи на уровне модуля или фичи: "Реализуй сервис аутентификации на FastAPI с JWT, учитывая наши существующие модели User и Session". Агент сам разбивает задачу на подзадачи, реализует, тестирует, коммитит. Вы проверяете результат постфактум.

### Типичные проблемы

- **Пропускная способность:** Производительность ограничена скоростью и контекстным окном одного агента. Вы не можете параллельно вести несколько потоков работ без потери качества.
- **Ручная координация:** Если у вас несколько независимых задач (frontend фича + backend фича + документация), приходится переключаться между ними вручную, теряя контекст.
- **Масштабирование:** На больших проектах (>100K строк кода, монорепо) агент начинает "задыхаться" — контекстное окно не вмещает всю кодовую базу, приходится тщательно фильтровать файлы.
- **Автоматизация процессов:** Код-ревью, запуск CI/CD, слияние результатов от агента в основную ветку — всё это требует ручных усилий. Нет единой системы управления несколькими агентами.

### Путь на следующий уровень

1. Научитесь работать с несколькими агентами параллельно: используйте git worktrees для изоляции контекстов, запускайте разные агенты на разные подзадачи одновременно.
2. Внедрите паттерны оркестрации: генератор + ревьюер, декомпозиция задач, иерархия агентов (координатор → исполнители).
3. Автоматизируйте контроль качества: настройте автоматический запуск тестов и линтеров, создайте runbook для стандартных задач, используйте fail-until-done подход (агент работает, пока тесты не пройдут).

#### Переход на следующий уровень

**Объективные критерии:**
- [ ] Освоены все навыки текущего уровня (оценка 4-5/5)
- [ ] Можете объяснить коллеге технику из следующего уровня

**Не готовы к переходу, если:**
- Разброс навыков >2 уровней (Level 3 в промптах, но Level 1 в debugging)
- Не понимаете "почему" работает ваш подход (только "как")
- Не можете воспроизвести результат осознанно

### Пример разработчика на этом уровне

**Елена, senior backend-разработчик на Go:** Работает через Claude Code с настроенными MCP-серверами для git, PostgreSQL и Jira. Утром открывает задачу в Jira, копирует ID. Ставит агенту задачу: "Реализуй фичу PROJ-1234. Прочитай описание из Jira, проверь схему БД через MCP, реализуй API по нашей конституции (AGENTS.md), покрой тестами, убедись что линтер проходит." Агент читает задачу из Jira, анализирует схему БД, пишет код, тесты, прогоняет golangci-lint, создаёт PR. Елена тратит 10 минут на ревью вместо 2 часов на реализацию. Но когда нужно одновременно реализовать 3 микросервиса для большой фичи, Елена делает их последовательно — параллельная работа с одним агентом невозможна, контекст путается.

---

## Уровень 5: Менеджер параллельных агентов (оркестратор)

**Что это:** Вы управляете несколькими агентами параллельно, распределяя между ними разные аспекты одной большой задачи или независимые задачи. Ваша роль — архитектор и координатор, а не кодер. Агенты работают автономно, вы мониторите прогресс и принимаете финальные решения.

### Характеристики

**Инструменты:** Несколько параллельных агентов (через git worktrees, docker контейнеры, headless-режим Claude Code, или платформы вроде OpenClaw). Оркестратор, который распределяет задачи и собирает результаты. Runbook — формализованный план работы. Системы мониторинга (логи агентов, heartbeat, метрики токенов).

**Промптинг:** Ролевая модель. Агент-архитектор планирует задачи, агент-разработчик реализует код (дешёвая модель), агент-QA проверяет тесты, агент-ревьюер проводит код-ревью (умная модель). Каждая роль — своя модель, свои инструменты, свой уровень автономности. Промпты структурированы как runbook: цель → подзадачи → кому какая → порядок → критерии приёмки → как сливать результаты.

**Надзор:** Стратегический. Вы не контролируете каждый шаг каждого агента — только мониторите прогресс через логи и метрики. Вмешиваетесь, когда агент зациклился (fail-until-done механизм), когда результаты агентов конфликтуют (разрешение конфликтов), или когда задача завершена (финальная приёмка). Агенты работают автономно внутри своих зон ответственности.

**Автономность:** Очень высокая. Агенты выполняют задачи от начала до конца без вашего участия. Fail-until-done: агент работает в цикле Do → Check (тесты/линтер) → Fix, пока тесты не пройдут. Hot-swap: если агент зациклился или провайдер недоступен, система автоматически переключается на другого агента. Вы получаете готовый PR, который только нужно проревьюить и влить.

### Типичные проблемы

- **Координация и конфликты:** Когда несколько агентов меняют связанные части кода, возникают конфликты. Их разрешение требует понимания, что сделал каждый агент и как объединить результаты.
- **Масштабируемость управления:** С ростом числа агентов и задач ручное управление становится неэффективным. Нужна автоматизация распределения задач, мониторинга, сборки результатов.
- **Отсутствие стандартов:** Каждая задача требует написания runbook с нуля. Нет единой системы для описания ролей, workflow, критериев приёмки — всё делается ad-hoc.
- **Риски автономности:** Агент может автоматически создать PR с багом, который пройдёт все тесты (если тесты неполные), но сломает продакшен. Финальная ответственность за результат всё равно на вас.

### Путь дальше

Уровень 5 — это не предел, но следующие шаги выходят за рамки курса:

1. **Архитектор автономных систем:** Использование фреймворков оркестрации (LangChain, AutoGPT, кастомные скрипты). Проектирование workflow как кода. Автоматическая валидация результатов. Построение отказоустойчивых систем, где сбой одного агента не ломает весь процесс.
2. **Интеграция в SDLC компании:** ИИ-агенты как часть CI/CD пайплайна. Автоматическое создание задач, реализация, тестирование, код-ревью, деплой. Метрики качества работы агентов. Управление бюджетом и стоимостью токенов на уровне команды или компании.
3. **Исследовательская работа:** Эксперименты с новыми моделями, паттернами, архитектурами. Вклад в open-source инструменты для агентной разработки. Публикация практик и уроков.

### Пример разработчика на этом уровне

**Антон, tech lead в стартапе:** Управляет разработкой платформы из 7 микросервисов на Go через флит агентов (концепция, демонстрируемая в проекте **Enji Fleet**). Утром Антон получает задачу от продакта: "Добавить экспорт отчётов в PDF для модуля аналитики". Антон пишет runbook: декомпозирует задачу на подзадачи (1. API endpoint, 2. PDF-генератор, 3. Тесты, 4. Документация), назначает каждую подзадачу агенту через платформу. Агент-архитектор читает конституцию проекта, планирует архитектуру. Три агента-разработчика параллельно реализуют код в изолированных git worktrees. Агент-QA пишет интеграционные тесты. Агент-ревьюер проверяет код, находит проблемы, возвращает на доработку. Fail-until-done механизм гарантирует, что агенты не остановятся, пока тесты не пройдут. Через 4 часа Антон получает 4 готовых PR с Telegram-уведомлением. Он тратит 30 минут на финальное ревью, вливает ветки, деплоит в staging. Задача, которая заняла бы 3 дня работы команды из 3 разработчиков, закрыта за полдня силами одного человека и флита агентов.

---

> [Диаграмма: Навыки по уровням](./diagrams/skills-radar.md)

### Матрица навыков по уровням

| Навык | Level 1 | Level 2 | Level 3 | Level 4 | Level 5 |
|-------|---------|---------|---------|---------|---------|
| **Prompt Engineering** | Копирует примеры | Адаптирует шаблоны | Создаёт эффективные промпты с нуля | Знает antipatterns, системные промпты | Оптимизирует цепочки, знает edge cases |
| **Работа с контекстом** | Не понимает лимиты | Следит за размером | Управляет контекстом осознанно | Структурирует с XML, знает window sliding | Продвинутые техники (RAG, сжатие) |
| **Tool use** | Не использует | Базовые команды (read, write) | Интеграции с API | Создаёт кастомные инструменты | MCP серверы, многоагентные системы |
| **Debugging AI** | Не знает как | Переформулирует | Анализирует отказы, меняет стратегию | Тестирует edge cases, знает ограничения | Воспроизводит баги, знает внутренности |
| **Автоматизация** | Вручную всё | Копипаста в чат | Скрипты с AI | CI/CD интеграции | Агентные системы с autonomy |
| **Code review** | Принимает всё | Проверяет синтаксис | Оценивает архитектуру | Выявляет security, performance | Знает trade-offs, может объяснить AI выбор |

**Как пользоваться:**
- Оцените себя честно по каждому навыку (1-5)
- Средний балл ≈ ваш уровень зрелости
- Разброс >2 между навыками → нужно выровнять слабые зоны
