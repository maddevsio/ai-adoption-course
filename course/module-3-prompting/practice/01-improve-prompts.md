# Упражнение 1: Улучши промпт (10 мин)

Научиться распознавать "плохие" промпты и превращать их в эффективные задания для ИИ-агента.

Ниже три типичных "плохих" промпта из реальной разработки. Для каждого:
1. Определите, что в нём не так
2. Изучите эталонный улучшенный вариант
3. Запустите оба промпта на своём проекте
4. Сравните результаты

---

### Плохой промпт 1: Функция валидации

```
Напиши функцию для валидации
```

**Что не так:**
- Нет контекста: какой язык программирования?
- Нет спецификации: что именно валидировать?
- Нет требований: какие правила валидации?
- Нет указания: куда поместить функцию?
- Нет критериев: как определить, что функция работает правильно?

**Эталонный улучшенный вариант:**

```
Создай функцию для валидации email-адреса в проекте на TypeScript.

Контекст:
- Проект: REST API на NestJS
- Файл: src/utils/validators.ts
- Существующие валидаторы используют class-validator decorators

Требования:
- Имя функции: isValidEmail(email: string): boolean
- Проверки: базовый формат email (наличие @, домена, корректные символы)
- Не должна пропускать: пустые строки, строки без @, домены без точки
- Должна принимать: стандартные email вида user@domain.com

Формат:
- Экспортируемая функция
- JSDoc-комментарий с описанием и примерами

Критерии приёмки:
- Функция компилируется без ошибок TypeScript
- Покрыта unit-тестами (минимум 5 кейсов: валидный email, пустая строка, без @, без домена, с невалидными символами)
- Соответствует code style проекта (ESLint)
```

---

### Плохой промпт 2: Рефакторинг

```
Отрефактори этот код чтобы было лучше
```

**Что не так:**
- "Лучше" — субъективная оценка без конкретных критериев
- Нет scope: что именно улучшать (читаемость, производительность, поддерживаемость)?
- Нет ограничений: можно ли менять публичный API? Переписать полностью?
- Нет контекста: какие паттерны и стиль приняты в проекте?
- Риск: агент может переписать код, нарушив существующую логику

**Эталонный улучшенный вариант:**

```
Отрефактори функцию processUserData() в файле src/services/userService.ts.

Контекст:
- Проект: Node.js backend на Express + TypeScript
- Текущие проблемы: функция содержит 120 строк, вложенность условий 4 уровня, дублирование логики валидации

Задачи рефакторинга:
1. Выделить методы-валидаторы (validateEmail, validateAge, validatePhone) в отдельный файл validators.ts
2. Разбить processUserData() на более мелкие функции по принципу Single Responsibility
3. Устранить дублирование через helper-функции
4. Снизить вложенность условий через early returns

Ограничения:
- НЕ менять сигнатуру функции processUserData (она используется в 5 других местах)
- Сохранить все существующие unit-тесты рабочими (tests/userService.test.ts)
- Не добавлять новые зависимости

Критерии приёмки:
- Цикломатическая сложность функции снижена до 10 или меньше
- Все существующие тесты проходят
- Код проходит ESLint без предупреждений
```

---

### Плохой промпт 3: Написание тестов

```
Напиши тесты
```

**Что не так:**
- Нет указания: что именно тестировать?
- Нет требований: какой coverage нужен?
- Нет спецификации: какие edge cases покрыть?
- Нет контекста: какой тестовый фреймворк используется?
- Нет ясности: unit, integration или e2e тесты?

**Эталонный улучшенный вариант:**

```
Напиши unit-тесты для класса OrderCalculator в файле src/services/orderCalculator.ts.

Контекст:
- Проект: e-commerce backend на NestJS + TypeScript
- Тестовый стек: Jest + @nestjs/testing
- Существующие тесты используют паттерн AAA (Arrange-Act-Assert)
- Путь к тестам: tests/unit/services/orderCalculator.test.ts

Что тестировать:
- calculateTotal(): суммирует цены items с учётом quantity
- applyDiscount(): применяет процентную или фиксированную скидку
- calculateTax(): добавляет налог в зависимости от региона

Покрываемые сценарии:
1. calculateTotal():
   - Один товар
   - Несколько товаров
   - Товар с quantity > 1
   - Пустой массив items (должен вернуть 0)

2. applyDiscount():
   - Процентная скидка (10%, 50%, 100%)
   - Фиксированная скидка
   - Скидка больше суммы заказа (итог не может быть < 0)
   - Нулевая скидка

3. calculateTax():
   - Регион с налогом 20%
   - Регион с налогом 0%
   - Неизвестный регион (по умолчанию 10%)

Формат:
- describe/it блоки
- Каждый тест: "should ... when ..."
- Mock внешних зависимостей (если есть)

Критерии приёмки:
- Все тесты проходят (npm test)
- Coverage не менее 90% для класса OrderCalculator
- Нет console.log или закомментированного кода
```

---

### Чеклист "хорошего промпта"

Перед отправкой промпта агенту проверьте наличие:

**Контекст:**
- [ ] Технологический стек (язык, фреймворки, библиотеки)
- [ ] Структура проекта (где находится файл, какие есть зависимости)
- [ ] Существующие паттерны и стиль кода

**Задача:**
- [ ] Конкретное действие (что именно сделать)
- [ ] Входные данные (с чем работать)
- [ ] Ожидаемый результат (что должно получиться)

**Формат:**
- [ ] Структура кода (классы, функции, модули)
- [ ] Соглашения об именовании
- [ ] Требования к документации (комментарии, JSDoc, etc.)

**Ограничения:**
- [ ] Что НЕ делать (breaking changes, новые зависимости)
- [ ] Совместимость (какой API сохранить)
- [ ] Производительность/безопасность (если критично)

**Критерии приёмки:**
- [ ] Как проверить успешность (тесты, линтеры, компиляция)
- [ ] Минимальные требования (coverage, сложность)
- [ ] Как убедиться, что задача выполнена
