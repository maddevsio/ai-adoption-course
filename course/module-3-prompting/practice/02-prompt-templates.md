[← Оглавление](../../../README.md)

# Упражнение 2: Промпты для разных задач (15 мин)

Создать шаблоны промптов для типичных задач разработки, которые можно использовать на своём проекте.

Для каждого типа:
1. Создайте шаблон с плейсхолдерами
2. Заполните пример на основе вашего реального проекта
3. Используйте чеклист для самопроверки

---

### Тип 1: Написание новой функции/модуля

**Шаблон:**

```
Создай [тип компонента] для [описание функциональности].

Контекст:
- Файл: [путь к файлу или место размещения]
- Зависимости: [существующие модули/файлы, которые будут использоваться]

Требования:
- [функциональное требование 1]
- [функциональное требование 2]
- [функциональное требование 3]
- [нефункциональное требование: производительность, безопасность]

Формат:
- [структура кода: класс/функция/модуль]
- [соглашения об именовании]
- [требования к документации]
- [обработка ошибок]

Критерии приёмки:
- [компиляция/линтеры]
- [покрытие тестами]
- [соответствие code style]
- [интеграция с существующим кодом]
```

**Пример заполненного промпта:**

```
Создай сервис для работы с уведомлениями (NotificationService).

Контекст:
- Проект: Task management приложение на NestJS
- Стек: TypeScript, NestJS, TypeORM, PostgreSQL, Bull (для очередей)
- Файл: src/modules/notifications/notification.service.ts
- Зависимости: UserRepository (src/modules/users/user.repository.ts), MailService (src/modules/mail/mail.service.ts)

Требования:
- Методы: sendEmail(userId, subject, body), sendBulk(userIds[], subject, body), scheduleNotification(userId, subject, body, sendAt)
- sendEmail: отправляет email одному пользователю немедленно
- sendBulk: добавляет задачи в Bull queue для массовой рассылки
- scheduleNotification: планирует отправку на определённое время через Bull
- Все методы должны логировать действия и обрабатывать ошибки

Формат:
- Injectable NestJS service с декоратором @Injectable()
- Dependency injection для UserRepository, MailService, Bull Queue
- Методы async/await
- Обработка ошибок через try-catch с логированием

Критерии приёмки:
- Код компилируется без ошибок TypeScript
- Все зависимости корректно инжектируются
- Покрытие unit-тестами минимум 80% (mock внешних сервисов)
- ESLint без warnings
```

**Чеклист самопроверки:**
- [ ] Указан конкретный технологический стек
- [ ] Определено место размещения файла
- [ ] Перечислены все зависимости и внешние модули
- [ ] Каждый метод/функция имеет чёткое описание
- [ ] Указаны требования к обработке ошибок
- [ ] Определены критерии успешности (тесты, линтеры)

---

### Тип 2: Написание тестов для существующего кода

**Шаблон:**

```
Напиши [тип тестов] для [компонент] в файле [путь к файлу].

Контекст:
- Существующие тесты: [где их можно найти]
- Путь к тестовому файлу: [где создать тесты]

Что тестировать:
- [метод/функция 1]: [описание поведения]
- [метод/функция 2]: [описание поведения]

Покрываемые сценарии:
[Метод 1]:
- [happy path сценарий]
- [edge case 1]
- [edge case 2]
- [error case]

Формат:
- [структура тестов: describe/it, test suites]
- [naming convention для тестов]
- [подход к mocking зависимостей]

Критерии приёмки:
- [все тесты проходят]
- [целевой coverage %]
- [время выполнения тестов]
- [соответствие стилю проекта]
```

**Пример заполненного промпта:**

```
Напиши unit-тесты для AuthService в файле src/auth/auth.service.ts.

Контекст:
- Проект: REST API для мобильного приложения на NestJS
- Тестовый стек: Jest, @nestjs/testing, @faker-js/faker для генерации данных
- Существующие тесты используют паттерн AAA (Arrange-Act-Assert) и моки через jest.fn()
- Путь к тестовому файлу: tests/unit/auth/auth.service.test.ts

Что тестировать:
- login(email, password): аутентификация пользователя, возврат access + refresh tokens
- register(userData): создание нового пользователя, хеширование пароля, возврат токенов
- refreshToken(refreshToken): обновление access token по валидному refresh token
- validateToken(accessToken): проверка валидности JWT токена

Покрываемые сценарии:
login():
- Успешный логин с валидными credentials
- Неверный email (throw UnauthorizedException)
- Неверный пароль (throw UnauthorizedException)
- Заблокированный пользователь (throw ForbiddenException)

register():
- Успешная регистрация нового пользователя
- Email уже занят (throw ConflictException)
- Невалидный email формат (throw BadRequestException)
- Слабый пароль < 8 символов (throw BadRequestException)

Формат:
- describe блок для каждого метода
- it/test с названием "should [результат] when [условие]"
- Mock для UserRepository, JwtService, bcrypt через jest.fn()
- Использовать @faker-js/faker для генерации тестовых данных

Критерии приёмки:
- Все тесты проходят (npm run test:unit)
- Coverage AuthService минимум 90%
- Время выполнения всех тестов < 2 секунд
- Нет реальных обращений к БД (все замокано)
```

**Чеклист самопроверки:**
- [ ] Указан тип тестов (unit/integration/e2e)
- [ ] Перечислены все методы для тестирования
- [ ] Для каждого метода определены happy path + edge cases + error cases
- [ ] Указан подход к mocking внешних зависимостей
- [ ] Определён целевой coverage
- [ ] Указаны требования к времени выполнения (если важно)
---

[← Упражнение 1: Улучши промпт (10 мин)](01-improve-prompts.md) | [Оглавление](../../../README.md) | [Упражнение 3: Игра Gandalf (15 мин) →](03-gandalf.md)
