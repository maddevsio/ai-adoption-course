# Упражнение 2: Промпты для разных задач (15 мин)

Создать шаблоны промптов для типичных задач разработки, которые можно использовать на своём проекте.

Для каждого типа:
1. Создайте шаблон с плейсхолдерами
2. Заполните пример на основе вашего реального проекта
3. Используйте чеклист для самопроверки

---

### Тип 1: Написание новой функции/модуля

**Шаблон:**

```
Создай [тип компонента] для [описание функциональности].

Контекст:
- Файл: [путь к файлу или место размещения]
- Зависимости: [существующие модули/файлы, которые будут использоваться]

Требования:
- [функциональное требование 1]
- [функциональное требование 2]
- [функциональное требование 3]
- [нефункциональное требование: производительность, безопасность]

Формат:
- [структура кода: класс/функция/модуль]
- [соглашения об именовании]
- [требования к документации]
- [обработка ошибок]

Критерии приёмки:
- [компиляция/линтеры]
- [покрытие тестами]
- [соответствие code style]
- [интеграция с существующим кодом]
```

**Пример заполненного промпта:**

```
Создай сервис для работы с уведомлениями (NotificationService).

Контекст:
- Проект: Task management приложение на NestJS
- Стек: TypeScript, NestJS, TypeORM, PostgreSQL, Bull (для очередей)
- Файл: src/modules/notifications/notification.service.ts
- Зависимости: UserRepository (src/modules/users/user.repository.ts), MailService (src/modules/mail/mail.service.ts)

Требования:
- Методы: sendEmail(userId, subject, body), sendBulk(userIds[], subject, body), scheduleNotification(userId, subject, body, sendAt)
- sendEmail: отправляет email одному пользователю немедленно
- sendBulk: добавляет задачи в Bull queue для массовой рассылки
- scheduleNotification: планирует отправку на определённое время через Bull
- Все методы должны логировать действия и обрабатывать ошибки

Формат:
- Injectable NestJS service с декоратором @Injectable()
- Dependency injection для UserRepository, MailService, Bull Queue
- Методы async/await
- Обработка ошибок через try-catch с логированием

Критерии приёмки:
- Код компилируется без ошибок TypeScript
- Все зависимости корректно инжектируются
- Покрытие unit-тестами минимум 80% (mock внешних сервисов)
- ESLint без warnings
```

**Чеклист самопроверки:**
- [ ] Указан конкретный технологический стек
- [ ] Определено место размещения файла
- [ ] Перечислены все зависимости и внешние модули
- [ ] Каждый метод/функция имеет чёткое описание
- [ ] Указаны требования к обработке ошибок
- [ ] Определены критерии успешности (тесты, линтеры)

---

### Тип 2: Написание тестов для существующего кода

**Шаблон:**

```
Напиши [тип тестов] для [компонент] в файле [путь к файлу].

Контекст:
- Существующие тесты: [где их можно найти]
- Путь к тестовому файлу: [где создать тесты]

Что тестировать:
- [метод/функция 1]: [описание поведения]
- [метод/функция 2]: [описание поведения]

Покрываемые сценарии:
[Метод 1]:
- [happy path сценарий]
- [edge case 1]
- [edge case 2]
- [error case]

Формат:
- [структура тестов: describe/it, test suites]
- [naming convention для тестов]
- [подход к mocking зависимостей]

Критерии приёмки:
- [все тесты проходят]
- [целевой coverage %]
- [время выполнения тестов]
- [соответствие стилю проекта]
```

**Пример заполненного промпта:**

```
Напиши unit-тесты для AuthService в файле src/auth/auth.service.ts.

Контекст:
- Проект: REST API для мобильного приложения на NestJS
- Тестовый стек: Jest, @nestjs/testing, @faker-js/faker для генерации данных
- Существующие тесты используют паттерн AAA (Arrange-Act-Assert) и моки через jest.fn()
- Путь к тестовому файлу: tests/unit/auth/auth.service.test.ts

Что тестировать:
- login(email, password): аутентификация пользователя, возврат access + refresh tokens
- register(userData): создание нового пользователя, хеширование пароля, возврат токенов
- refreshToken(refreshToken): обновление access token по валидному refresh token
- validateToken(accessToken): проверка валидности JWT токена

Покрываемые сценарии:
login():
- Успешный логин с валидными credentials
- Неверный email (throw UnauthorizedException)
- Неверный пароль (throw UnauthorizedException)
- Заблокированный пользователь (throw ForbiddenException)

register():
- Успешная регистрация нового пользователя
- Email уже занят (throw ConflictException)
- Невалидный email формат (throw BadRequestException)
- Слабый пароль < 8 символов (throw BadRequestException)

Формат:
- describe блок для каждого метода
- it/test с названием "should [результат] when [условие]"
- Mock для UserRepository, JwtService, bcrypt через jest.fn()
- Использовать @faker-js/faker для генерации тестовых данных

Критерии приёмки:
- Все тесты проходят (npm run test:unit)
- Coverage AuthService минимум 90%
- Время выполнения всех тестов < 2 секунд
- Нет реальных обращений к БД (все замокано)
```

**Чеклист самопроверки:**
- [ ] Указан тип тестов (unit/integration/e2e)
- [ ] Перечислены все методы для тестирования
- [ ] Для каждого метода определены happy path + edge cases + error cases
- [ ] Указан подход к mocking внешних зависимостей
- [ ] Определён целевой coverage
- [ ] Указаны требования к времени выполнения (если важно)

---

### Тип 3: Debugging — поиск и исправление бага

**Шаблон:**

```
Найди и исправь баг в [компонент/файл].

Описание бага:
- Ожидаемое поведение: [что должно происходить]
- Фактическое поведение: [что происходит на самом деле]
- Шаги воспроизведения: [как воспроизвести]

Контекст:
- Стек: [язык, фреймворк]
- Stack trace / ошибка: [если есть]
- Что уже пробовали: [какие гипотезы проверяли]

Критерии приёмки:
- [баг исправлен, поведение соответствует ожидаемому]
- [существующие тесты проходят]
- [добавлен тест, предотвращающий регрессию]
```

**Пример заполненного промпта:**

```
Найди и исправь баг в src/services/auth.service.ts.

Описание бага:
- Ожидаемое поведение: refresh token обновляет access token и возвращает 200
- Фактическое поведение: возвращает 401 "Token expired" даже для валидных refresh tokens
- Шаги воспроизведения: POST /api/auth/refresh с валидным refresh token через 30+ минут после логина

Контекст:
- Стек: NestJS, TypeScript, jsonwebtoken
- Ошибка: JsonWebTokenError: jwt expired
- Что уже пробовали: проверили expiresIn для access token (30m) — корректно

Критерии приёмки:
- Refresh token корректно обновляет access token
- Все существующие тесты auth проходят
- Добавлен тест для refresh после 30+ минут
```

**Чеклист самопроверки:**
- [ ] Описаны ожидаемое и фактическое поведение
- [ ] Указаны шаги воспроизведения
- [ ] Приложен stack trace или текст ошибки
- [ ] Указано, что уже пробовали (чтобы агент не повторял)
- [ ] Определён критерий: баг исправлен + тест на регрессию

---

### Тип 4: Рефакторинг существующего кода

**Шаблон:**

```
Отрефактори [компонент/файл].

Проблема (code smell):
- [что именно плохо: дублирование, god object, длинный метод, нарушение SRP]

Желаемое улучшение:
- [как должно быть после рефакторинга]

Ограничения:
- [что нельзя менять: публичный API, схему БД, поведение]
- [какие паттерны применять]

Критерии приёмки:
- [поведение не изменилось (все тесты проходят)]
- [код стал чище по метрике X]
- [линтер без warnings]
```

**Пример заполненного промпта:**

```
Отрефактори src/controllers/order.controller.ts.

Проблема:
- Метод createOrder() — 150 строк, содержит валидацию, бизнес-логику, работу с БД и отправку email
- Нарушает SRP: один метод делает всё

Желаемое улучшение:
- Вынести валидацию в OrderValidator
- Вынести бизнес-логику в OrderService
- Вынести отправку email в NotificationService
- Controller остаётся тонким: принимает запрос → вызывает service → возвращает ответ

Ограничения:
- Публичный API endpoint не меняется (POST /api/orders, те же request/response)
- Используем существующий DI-контейнер NestJS
- Не менять схему БД

Критерии приёмки:
- Все существующие тесты проходят без изменений
- createOrder() в controller < 20 строк
- Каждый новый сервис покрыт unit-тестами
- ESLint без warnings
```

**Чеклист самопроверки:**
- [ ] Описана конкретная проблема (code smell), а не абстрактное "плохой код"
- [ ] Указано желаемое состояние после рефакторинга
- [ ] Определены ограничения (что нельзя ломать)
- [ ] Главный критерий: поведение не изменилось (тесты проходят)
