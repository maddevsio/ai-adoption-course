# Упражнение 2: Промпты для разных задач (15 мин)

Создать шаблоны промптов для типичных задач разработки, которые можно использовать на своём проекте.

Для каждого типа:
1. Создайте шаблон с плейсхолдерами
2. Заполните пример на основе вашего реального проекта
3. Используйте чеклист для самопроверки

---

### Тип 1: Написание новой функции/модуля

**Шаблон:**

```
Создай [тип компонента] для [описание функциональности].

Контекст:
- Проект: [описание проекта и его назначение]
- Стек: [язык, фреймворки, библиотеки]
- Файл: [путь к файлу или место размещения]
- Зависимости: [существующие модули/файлы, которые будут использоваться]

Требования:
- [функциональное требование 1]
- [функциональное требование 2]
- [функциональное требование 3]
- [нефункциональное требование: производительность, безопасность]

Формат:
- [структура кода: класс/функция/модуль]
- [соглашения об именовании]
- [требования к документации]
- [обработка ошибок]

Критерии приёмки:
- [компиляция/линтеры]
- [покрытие тестами]
- [соответствие code style]
- [интеграция с существующим кодом]
```

**Пример заполненного промпта:**

```
Создай сервис для работы с уведомлениями (NotificationService).

Контекст:
- Проект: Task management приложение на NestJS
- Стек: TypeScript, NestJS, TypeORM, PostgreSQL, Bull (для очередей)
- Файл: src/modules/notifications/notification.service.ts
- Зависимости: UserRepository (src/modules/users/user.repository.ts), MailService (src/modules/mail/mail.service.ts)

Требования:
- Методы: sendEmail(userId, subject, body), sendBulk(userIds[], subject, body), scheduleNotification(userId, subject, body, sendAt)
- sendEmail: отправляет email одному пользователю немедленно
- sendBulk: добавляет задачи в Bull queue для массовой рассылки
- scheduleNotification: планирует отправку на определённое время через Bull
- Все методы должны логировать действия и обрабатывать ошибки

Формат:
- Injectable NestJS service с декоратором @Injectable()
- Dependency injection для UserRepository, MailService, Bull Queue
- Методы async/await
- Обработка ошибок через try-catch с логированием

Критерии приёмки:
- Код компилируется без ошибок TypeScript
- Все зависимости корректно инжектируются
- Покрытие unit-тестами минимум 80% (mock внешних сервисов)
- ESLint без warnings
```

**Чеклист самопроверки:**
- [ ] Указан конкретный технологический стек
- [ ] Определено место размещения файла
- [ ] Перечислены все зависимости и внешние модули
- [ ] Каждый метод/функция имеет чёткое описание
- [ ] Указаны требования к обработке ошибок
- [ ] Определены критерии успешности (тесты, линтеры)

---

### Тип 2: Написание тестов для существующего кода

**Шаблон:**

```
Напиши [тип тестов] для [компонент] в файле [путь к файлу].

Контекст:
- Проект: [описание проекта]
- Тестовый стек: [фреймворк, библиотеки для тестирования]
- Существующие тесты: [паттерны и стиль текущих тестов]
- Путь к тестовому файлу: [где создать тесты]

Что тестировать:
- [метод/функция 1]: [описание поведения]
- [метод/функция 2]: [описание поведения]
- [метод/функция 3]: [описание поведения]

Покрываемые сценарии:
[Метод 1]:
- [happy path сценарий]
- [edge case 1]
- [edge case 2]
- [error case]

[Метод 2]:
- [happy path сценарий]
- [edge case 1]
- [error case]

Формат:
- [структура тестов: describe/it, test suites]
- [naming convention для тестов]
- [подход к mocking зависимостей]

Критерии приёмки:
- [все тесты проходят]
- [целевой coverage %]
- [время выполнения тестов]
- [соответствие стилю проекта]
```

**Пример заполненного промпта:**

```
Напиши unit-тесты для AuthService в файле src/auth/auth.service.ts.

Контекст:
- Проект: REST API для мобильного приложения на NestJS
- Тестовый стек: Jest, @nestjs/testing, @faker-js/faker для генерации данных
- Существующие тесты используют паттерн AAA (Arrange-Act-Assert) и моки через jest.fn()
- Путь к тестовому файлу: tests/unit/auth/auth.service.test.ts

Что тестировать:
- login(email, password): аутентификация пользователя, возврат access + refresh tokens
- register(userData): создание нового пользователя, хеширование пароля, возврат токенов
- refreshToken(refreshToken): обновление access token по валидному refresh token
- validateToken(accessToken): проверка валидности JWT токена

Покрываемые сценарии:
login():
- Успешный логин с валидными credentials
- Неверный email (throw UnauthorizedException)
- Неверный пароль (throw UnauthorizedException)
- Заблокированный пользователь (throw ForbiddenException)

register():
- Успешная регистрация нового пользователя
- Email уже занят (throw ConflictException)
- Невалидный email формат (throw BadRequestException)
- Слабый пароль < 8 символов (throw BadRequestException)

refreshToken():
- Успешное обновление с валидным refresh token
- Истёкший refresh token (throw UnauthorizedException)
- Невалидный токен (throw UnauthorizedException)

validateToken():
- Валидный токен возвращает payload
- Истёкший токен (throw UnauthorizedException)
- Подделанный токен (throw UnauthorizedException)

Формат:
- describe блок для каждого метода
- it/test с названием "should [результат] when [условие]"
- Mock для UserRepository, JwtService, bcrypt через jest.fn()
- Использовать @faker-js/faker для генерации тестовых данных

Критерии приёмки:
- Все тесты проходят (npm run test:unit)
- Coverage AuthService минимум 90%
- Время выполнения всех тестов < 2 секунд
- Нет реальных обращений к БД (все замокано)
```

**Чеклист самопроверки:**
- [ ] Указан тип тестов (unit/integration/e2e)
- [ ] Перечислены все методы для тестирования
- [ ] Для каждого метода определены happy path + edge cases + error cases
- [ ] Указан подход к mocking внешних зависимостей
- [ ] Определён целевой coverage
- [ ] Указаны требования к времени выполнения (если важно)

---

### Тип 3: Рефакторинг существующего кода

**Шаблон:**

```
Отрефактори [компонент] в файле [путь к файлу].

Контекст:
- Проект: [описание проекта]
- Стек: [технологии]
- Текущие проблемы: [code smells, метрики сложности]

Задачи рефакторинга:
1. [конкретная задача 1]
2. [конкретная задача 2]
3. [конкретная задача 3]

Ограничения:
- НЕ [что нельзя делать]
- Сохранить [что должно остаться неизменным]
- Не добавлять [запреты на новые зависимости/паттерны]

Критерии приёмки:
- [метрики качества: сложность, дублирование]
- [тесты проходят]
- [совместимость]
- [code style]
```

**Пример заполненного промпта:**

```
Отрефактори класс ReportGenerator в файле src/reports/reportGenerator.ts.

Контекст:
- Проект: Analytics dashboard backend на Node.js + TypeScript
- Стек: Express, TypeORM, PostgreSQL, ExcelJS для генерации отчётов
- Текущие проблемы: метод generateReport() содержит 250 строк, цикломатическая сложность 25, дублирование логики форматирования в 4 местах, вложенность циклов 3 уровня

Задачи рефакторинга:
1. Выделить форматирование в отдельные функции (formatCurrency, formatDate, formatPercentage) в utils/formatters.ts
2. Разбить generateReport() на методы: fetchData(), processData(), formatReport(), exportToExcel()
3. Извлечь константы (названия колонок, форматы дат) в enums или config
4. Устранить дублирование через helper-функции
5. Снизить вложенность через функциональные методы (map, filter, reduce)
6. Добавить типизацию для промежуточных данных (RawData, ProcessedData, FormattedReport)

Ограничения:
- НЕ менять публичный метод generateReport(userId, dateFrom, dateTo, format) — используется в 8 контроллерах
- Сохранить все существующие unit-тесты рабочими
- Не добавлять новые npm зависимости
- Не менять формат выходных Excel файлов

Критерии приёмки:
- Цикломатическая сложность generateReport() снижена до 10 или меньше
- Самый длинный метод не превышает 50 строк
- Все существующие тесты проходят без изменений
- Новые helper-функции покрыты unit-тестами
- TypeScript strict mode без ошибок
```

**Чеклист самопроверки:**
- [ ] Определены конкретные code smells для устранения
- [ ] Перечислены конкретные задачи рефакторинга
- [ ] Указаны жёсткие ограничения (API, тесты, зависимости)
- [ ] Определены метрики успешности (сложность, длина методов)
- [ ] Требуется сохранение работоспособности существующих тестов
