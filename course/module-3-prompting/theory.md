# Модуль 3: Промптинг — от вопросов к заданиям

## Ключевой сдвиг: вопрос → задание

Главное различие между начинающим и зрелым пользователем ИИ-инструментов не в том, сколько он знает фреймворков или хитрых трюков промптинга. Разница в ментальной модели: воспринимает ли он ИИ как поисковую систему или как исполнителя.

**Вопрос** предполагает получение информации: "Как сделать JWT-авторизацию в FastAPI?" Такой запрос приводит к общему ответу с примерами из документации, который нужно адаптировать самостоятельно. **Задание** формулирует конкретную задачу с контекстом: "Реализуй JWT-авторизацию для FastAPI с использованием модели User из models.py, создай эндпоинты /login и /refresh, токен должен содержать user_id и роль, время жизни access token — 15 минут, refresh — 7 дней". Такой промпт приводит к коду, готовому к интеграции в проект.

Переход от вопросов к заданиям — это переход от уровня 1-2 (чат-кодинг, копилот) к уровню 3+ (делегирование агенту). Это изменение в подходе открывает возможность работы с автономными агентами, которые не консультируют, а выполняют.

## Структура промпта для coding agents

Эффективный промпт для агента состоит из четырёх блоков:

**1. Роль (Role)** — определяет компетенции и контекст работы агента. Не просто "ты программист", а конкретная экспертиза: "Ты senior backend developer, специализирующийся на Go и микросервисной архитектуре, с глубоким пониманием gRPC и Protocol Buffers".

**2. Контекст (Context)** — описывает проект, технический стек и ограничения. Пример: "Проект — распределённая система обработки событий. Стек: Go 1.21, gRPC, PostgreSQL, Redis для кеширования. Кодовая база следует Clean Architecture. Существующие сервисы: auth-service, user-service, event-processor. Ограничение: все внешние вызовы должны иметь timeout 5 секунд и retry с exponential backoff".

**3. Задача (Task)** — конкретное действие, которое должен выполнить агент. "Создай новый gRPC-сервис notification-service с методами SendEmail и SendPush. Реализуй интерфейс NotificationRepository для работы с PostgreSQL. Добавь middleware для логирования всех запросов с tracing ID. Интегрируй с auth-service для проверки токенов".

**4. Критерии приёмки (Acceptance Criteria)** — условия, при которых задача считается выполненной. "Код должен: 1) компилироваться без ошибок, 2) покрываться unit-тестами минимум на 80%, 3) включать integration-тесты для gRPC endpoints, 4) содержать proto-файлы с документацией для всех RPC методов, 5) следовать проектному code style (gofmt + golangci-lint)".

### Альтернатива: PPFO Framework

Другой подход к структурированию промптов — PPFO:

- **Purpose** (Цель): зачем нужна эта задача, какую проблему решает
- **Planning** (План): последовательность шагов для достижения цели
- **Format** (Формат): структура ожидаемого результата (тип файлов, архитектура, стиль кода)
- **Output** (Выход): конкретные артефакты (файлы, тесты, документация)

Пример PPFO-промпта: "**Purpose**: Добавить rate limiting для защиты API от злоупотреблений. **Planning**: 1) Реализовать middleware в TypeScript, 2) Использовать Redis для хранения счётчиков, 3) Настроить лимиты для разных ролей, 4) Добавить заголовки с информацией о лимитах. **Format**: Express middleware с TypeScript типами, конфигурация через environment variables. **Output**: middleware/rateLimiter.ts, тесты в tests/rateLimiter.test.ts, обновлённый app.ts с подключением middleware, README с примерами использования".

Чем точнее критерии приёмки, тем меньше итераций требуется для получения работающего результата. Для агентных инструментов промпт определяет не просто ответ, а целую цепочку действий: чтение файлов, генерация кода, запуск тестов, рефакторинг при ошибках.

## Продвинутые техники промптинга

### Ролевая постановка (Role Assignment)

Задание конкретной роли с детализацией экспертизы направляет модель к более точным и профессиональным решениям. Вместо абстрактного "ты программист" используйте специфичную роль.

**Пример**: "Ты DevOps-инженер с 8-летним опытом работы с Kubernetes и Terraform. Ты знаешь best practices для production-окружений: zero-downtime deployments, proper health checks, resource limits, secrets management через external secrets operator".

**Когда использовать**: При работе над задачами, требующими глубокой доменной экспертизы — архитектурные решения, выбор паттернов, security-критичный код. Ролевая постановка особенно эффективна для рефакторинга и code review, где важен опыт и понимание последствий решений.

**Почему это важно**: Модель обучалась на огромном количестве кода разного качества. Явное указание уровня экспертизы сдвигает распределение вероятностей в сторону более качественных, идиоматичных решений. Это не магия, а статистический эффект: код senior-разработчика в обучающем датасете чаще содержит error handling, тесты, документацию.

### Few-shot примеры (Few-shot Learning)

Few-shot промптинг — это предоставление 2-4 примеров ожидаемого результата перед основным запросом. Модель учится на этих примерах и воспроизводит паттерн.

**Пример для генерации API endpoints**:

```
Создавай REST API endpoints в таком стиле:

# Пример 1:
# GET /api/users/:id
@router.get("/users/{user_id}")
async def get_user(user_id: int, db: Session = Depends(get_db)):
    user = db.query(User).filter(User.id == user_id).first()
    if not user:
        raise HTTPException(status_code=404, detail="User not found")
    return UserResponse.from_orm(user)

# Пример 2:
# POST /api/users
@router.post("/users", status_code=201)
async def create_user(user_data: UserCreate, db: Session = Depends(get_db)):
    user = User(**user_data.dict())
    db.add(user)
    db.commit()
    db.refresh(user)
    return UserResponse.from_orm(user)

Теперь создай endpoint DELETE /api/users/:id с такой же структурой.
```

**Когда использовать**: Когда нужен специфичный стиль кода, необычная структура проекта, или уникальные паттерны вашей команды. Few-shot незаменим для генерации тестов в определённом формате, миграций БД, конфигурационных файлов.

**Почему это важно**: Few-shot обходит проблему "я знаю, что хочу, но не могу описать словами". Вместо попыток формализовать правила, вы просто показываете примеры. Это особенно эффективно для DSL, шаблонов, и кода с нестандартной структурой.

### Prompt Chaining (Цепочка промптов)

Разбиение сложной задачи на последовательность более простых запросов, где выход каждого шага становится входом следующего.

**Пример цепочки для рефакторинга легаси-кода**:

```
Шаг 1: "Проанализируй функцию processOrder() и выдели все её обязанности (responsibilities). Перечисли их списком."

Шаг 2: "Основываясь на списке обязанностей, предложи декомпозицию функции на отдельные функции согласно Single Responsibility Principle. Дай название и сигнатуру каждой функции."

Шаг 3: "Реализуй функцию validateOrderData() из предложенной декомпозиции. Включи все необходимые проверки из оригинального кода."

Шаг 4: "Перепиши processOrder(), используя новые функции. Сохрани исходное поведение."

Шаг 5: "Создай unit-тесты для каждой новой функции."
```

**Когда использовать**: Для задач, требующих анализа, проектирования и реализации. Вместо одного "god-prompt" с инструкцией "отрефактори всё", цепочка даёт контроль над процессом и позволяет корректировать направление на каждом шаге.

**Почему это важно**: Сложные задачи требуют планирования. Одношаговый промпт часто приводит к поверхностным решениям или полной переписи кода с потерей важной логики. Chaining имитирует процесс работы опытного разработчика: сначала понять, потом спланировать, потом реализовать.

### Self-Consistency (Самопроверка)

Техника, при которой агент проверяет свой собственный результат по заданным критериям.

**Пример**: После генерации кода добавьте в промпт: "Теперь проверь сгенерированный код на: 1) наличие race conditions в горутинах, 2) корректность закрытия ресурсов (defer для файлов и соединений), 3) обработку всех возможных ошибок, 4) соответствие Go best practices. Перечисли найденные проблемы и предложи исправления."

**Когда использовать**: Для критичного кода — безопасность, производительность, обработка денежных транзакций. Self-consistency особенно полезна при работе с параллелизмом, асинхронностью, сложными условиями.

**Почему это важно**: Модель хороша в поиске проблем, но может их пропустить в процессе генерации. Явный запрос на проверку активирует другой режим мышления (критический анализ вместо генерации), что часто выявляет неочевидные баги.

### Constraint Prompting (Ограничения)

Жёсткие ограничения на формат, структуру или содержание результата.

**Пример для Go**:
```
Требования:
- Все публичные функции и типы должны иметь godoc комментарии
- Ошибки должны оборачиваться через fmt.Errorf с %w для error wrapping
- Не использовать panic, только возврат ошибок
- Все SQL-запросы через prepared statements ($1, $2...)
- Имена переменных в camelCase, длина переменных больше 2 символов
- Максимальная цикломатическая сложность функции — 10
```

**Когда использовать**: Когда проект имеет строгие code style guidelines, security requirements, или специфичные архитектурные ограничения. Constraint prompting критичен для enterprise-разработки, где код должен проходить автоматические проверки (linters, security scanners).

**Почему это важно**: Предотвращает необходимость многократных итераций для приведения кода к стандартам проекта. Явные ограничения в промпте работают как виртуальный code reviewer, который не пропустит код, нарушающий правила.

## Антипаттерны промптинга

### 1. Нечёткие формулировки

**Проблема**: Использование оценочных суждений и неопределённых требований.

**Плохо**: "Оптимизируй эту функцию", "Сделай код красивее", "Улучши производительность".

**Почему плохо**: "Оптимизировать" может означать скорость, память, читаемость, размер кода — что угодно. Модель выберет случайное направление, которое может не совпадать с вашими ожиданиями.

**Хорошо**: "Оптимизируй функцию calculateStats() для работы с массивами размером 100K+ элементов. Текущая проблема: O(n²) из-за вложенных циклов. Цель: снизить сложность до O(n log n) или O(n). Можно использовать дополнительную память. Сохрани текущую сигнатуру функции и покрой изменения тестами."

### 2. God-Prompt (всё в одном)

**Проблема**: Попытка вместить всю задачу в один огромный промпт.

**Плохо**: "Создай микросервис для обработки платежей с интеграцией Stripe, PostgreSQL для хранения транзакций, Redis для кеширования, RabbitMQ для событий, API для фронтенда, admin-панель для мониторинга, написать тесты, документацию и Docker Compose для развёртывания."

**Почему плохо**: Агент попытается сгенерировать всё сразу, что приведёт к поверхностной реализации, пропущенным деталям, несогласованности между компонентами. Чем больше задач в одном промпте, тем ниже качество каждой.

**Хорошо**: Разбить на этапы:
1. Спроектировать структуру сервиса и определить основные компоненты
2. Реализовать модели данных и репозиторий для PostgreSQL
3. Создать интеграцию со Stripe API
4. Добавить API endpoints для основных операций
5. Настроить RabbitMQ для публикации событий
6. Написать тесты для критичной логики
7. Создать Dockerfile и Docker Compose

### 3. Отсутствие контекста

**Проблема**: Запросы без указания стека, архитектуры проекта, существующего кода.

**Плохо**: "Напиши функцию для аутентификации пользователя."

**Почему плохо**: Агент не знает: какой язык, какой фреймворк, где хранятся пользователи, какая схема БД, какой механизм аутентификации (JWT, sessions, OAuth), какие библиотеки уже используются в проекте. Результат будет несовместим с существующей кодовой базой.

**Хорошо**: "В проекте на NestJS (TypeScript) с TypeORM и PostgreSQL реализуй функцию для аутентификации пользователя. Используй существующую сущность User (entities/user.entity.ts) с полями email и passwordHash. Пароли хешируются через bcrypt. Аутентификация через JWT (access + refresh tokens). У нас уже есть AuthModule, добавь метод в AuthService. Верни оба токена и user_id."

## Промптинг для разных типов задач

Разные задачи требуют разных подходов к промптингу. Универсальной формулы нет, но есть паттерны, которые работают для определённых категорий.

### Разработка новой функциональности

Фокус на спецификации, контракте, тестируемости. Начните с определения интерфейса перед реализацией.

**Пример (TypeScript)**: "Спроектируй и реализуй класс CacheManager для работы с Redis. Интерфейс: get(key), set(key, value, ttl), delete(key), exists(key). Все методы async. Используй ioredis. Реализуй автоматическую сериализацию/десериализацию JSON. Добавь error handling для сетевых ошибок. Покрой unit-тестами с использованием redis-mock."

### Рефакторинг

Подчеркните сохранение поведения и необходимость тестов. Укажите конкретные code smells, которые нужно устранить.

**Пример (Python)**: "Отрефактори класс DataProcessor (src/processor.py). Проблемы: метод process() содержит 150 строк, вложенность условий 5 уровней, дублирование логики валидации в трёх местах. Задачи: 1) Выдели методы-валидаторы, 2) Разбей process() на более мелкие методы по SRP, 3) Извлеки константы в enum, 4) Убери дублирование через helper-функции. Сохрани все существующие тесты рабочими. Не меняй публичный API класса."

### Написание тестов

Укажите типы тестов, покрываемые сценарии, используемый фреймворк. Требуйте edge cases.

**Пример (Go)**: "Напиши unit-тесты для функции ParseURL(raw string) (URL, error). Используй testing и testify/assert. Покрой случаи: 1) валидный URL, 2) URL без схемы (http:// по умолчанию), 3) пустая строка (ошибка), 4) невалидные символы (ошибка), 5) очень длинный URL (2000+ символов), 6) URL с unicode-символами в параметрах. Используй table-driven tests. Каждый кейс должен проверять как результат, так и наличие/отсутствие ошибки."

### Документация

Укажите целевую аудиторию, формат, уровень детализации. Требуйте примеры использования.

**Пример**: "Напиши API-документацию для REST endpoint POST /api/orders в формате OpenAPI 3.0. Включи: описание эндпоинта, request body schema (OrderCreateRequest), response schema (OrderResponse), возможные HTTP статусы (201, 400, 401, 500) с описанием, пример curl-запроса, пример успешного и ошибочного response. Аудитория — frontend-разработчики, не знакомые с backend-логикой."

### Планирование архитектуры

Запрашивайте рассуждения (reasoning) перед решением. Требуйте trade-offs и альтернативы.

**Пример**: "Нужно спроектировать систему для обработки 10K событий/сек с гарантией exactly-once delivery. События приходят через Kafka, обрабатываются асинхронно (занимает 50-500ms), результат пишется в PostgreSQL. Предложи архитектуру на Go: 1) Опиши компоненты системы, 2) Объясни, как обеспечить exactly-once (учитывая, что Kafka даёт at-least-once), 3) Покажи, как масштабировать при росте нагрузки, 4) Рассмотри trade-offs: простота vs производительность vs надёжность. Дай аргументы за и против каждого решения."

---

Промптинг — это навык, который развивается через практику. Начинайте с чёткой структуры (роль, контекст, задача, критерии), экспериментируйте с техниками (few-shot, chaining, constraints), избегайте антипаттернов (нечёткость, god-prompt, отсутствие контекста). С опытом придёт интуиция, когда какой подход использовать, но основа всегда одна: чем яснее вы сформулируете задачу для агента, тем ближе результат к ожиданиям с первого раза.
