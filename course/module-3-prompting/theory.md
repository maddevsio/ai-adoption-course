# Модуль 3: Промптинг — от вопросов к заданиям

## Ключевой сдвиг: вопрос → задание

Главное различие между начинающим и опытным пользователем ИИ-инструментов — не в знании хитрых трюков, а в ментальной модели. Новичок воспринимает ИИ как поисковую систему, эксперт — как исполнителя.

**Вопрос** запрашивает информацию: "Как сделать JWT-авторизацию в FastAPI?" Вы получите общий ответ из документации, который нужно адаптировать самостоятельно. **Задание** формулирует конкретную задачу: "Реализуй JWT-авторизацию для FastAPI с использованием модели User из models.py, создай эндпоинты /login и /refresh, токен должен содержать user_id и роль, время жизни access token — 15 минут, refresh — 7 дней". Вы получите код, готовый к интеграции.

Переход от вопросов к заданиям — это переход с уровня 1-2 (чат-кодинг, копилот) на уровень 3+ (делегирование агенту). Вместо консультанта вы получаете автономного исполнителя.

## Структура промпта для coding agents

Эффективный промпт состоит из четырёх блоков. Каждый блок важен — пропуск любого снижает качество результата.

### 1. Роль (Role) — кто выполняет задачу

Определяет компетенции агента. Не "ты программист", а конкретная экспертиза.

**Пример**: "Ты senior backend developer, специализируешься на Go и микросервисной архитектуре, глубоко понимаешь gRPC, Protocol Buffers и паттерны распределённых систем."

Зачем: модель обучалась на коде разного качества. Явное указание экспертизы сдвигает вероятности к решениям с error handling, тестами, документацией — то, что пишут senior-разработчики.

### 2. Контекст (Context) — в каких условиях

Описывает проект, стек, ограничения. Без контекста агент изобретёт свой, который не совпадёт с вашим.

**Пример**: "Проект — система обработки платежей. Стек: Python 3.11, FastAPI, PostgreSQL, Redis для кеширования. Архитектура: repository pattern, сервисы, контроллеры. Существующие модули: auth, users, transactions. Обязательно: все внешние API-вызовы с timeout 5 секунд, retry с exponential backoff, логирование всех операций с деньгами."

Контекст отвечает на вопросы: какой язык и версия, какие фреймворки, какая архитектура, что уже есть в проекте, какие правила нельзя нарушать.

### 3. Задача (Task) — что конкретно сделать

Конкретное действие, которое должен выполнить агент. Не "добавь функционал платежей", а детальная спецификация.

**Пример**: "Создай сервис PaymentProcessor в services/payment.py. Методы: create_payment(user_id, amount, currency) → возвращает payment_id и статус, check_payment_status(payment_id) → возвращает enum (pending, success, failed). Интеграция с Stripe API через существующий StripeClient из lib/stripe_client.py. Сохранение всех транзакций в таблицу payments через PaymentRepository. При ошибках Stripe — rollback транзакции, логирование, возврат специфичной ошибки."

### 4. Критерии приёмки (Acceptance Criteria) — как понять, что готово

Условия, при которых задача считается выполненной. Чем точнее критерии, тем меньше итераций.

**Пример**: "Код должен: 1) проходить mypy без ошибок, 2) покрываться pytest unit-тестами минимум 85%, 3) включать моки для Stripe API, 4) следовать black + isort для форматирования, 5) содержать docstrings для всех публичных методов, 6) обрабатывать все exceptions от Stripe с конкретными сообщениями."

Для агентных инструментов промпт определяет цепочку действий: чтение файлов, генерация, запуск тестов, рефакторинг при ошибках.

### Альтернатива: PPFO Framework

PPFO — другой подход к структурированию, популярный в контексте DeepSeek и coding agents:

- **Purpose** (Цель) — зачем нужна эта задача, какую проблему решает
- **Planning** (План) — последовательность шагов
- **Format** (Формат) — структура результата (файлы, архитектура, стиль)
- **Output** (Выход) — конкретные артефакты

**Пример PPFO-промпта**:

```
Purpose: Добавить rate limiting для защиты API от злоупотреблений.
Текущая проблема: нет ограничений на количество запросов, возможен DDoS.

Planning:
1. Реализовать middleware в TypeScript для Express
2. Использовать Redis для хранения счётчиков запросов
3. Настроить разные лимиты для ролей: анонимы 100 req/min,
   авторизованные 1000 req/min, admin без лимитов
4. Добавить заголовки X-RateLimit-Limit, X-RateLimit-Remaining

Format:
Express middleware с TypeScript типами, конфигурация через env variables,
injectable зависимости для тестируемости

Output:
middleware/rateLimiter.ts,
tests/rateLimiter.test.ts,
обновлённый app.ts с подключением middleware,
README с примерами использования и конфигурации
```

PPFO работает хорошо для задач, где важна последовательность шагов. Четырёхблочная структура (роль-контекст-задача-критерии) лучше для задач, где важен технический контекст и стиль кода.

## Продвинутые техники промптинга

Базовые техники (chain-of-thought, пошаговые инструкции) модели уже применяют сами. Фокусируемся на нетривиальных — тех, что модель сама не предложит.

### Ролевая постановка (Role Assignment)

Задание конкретной роли с детализацией экспертизы направляет модель к профессиональным решениям.

**Когда использовать**: архитектурные решения, выбор паттернов, security-критичный код, рефакторинг, code review — везде, где важен опыт и понимание последствий.

**Пример для DevOps-задачи**:
```
Ты DevOps-инженер с 8-летним опытом работы с Kubernetes в production.
Знаешь best practices: zero-downtime deployments, proper health checks
(liveness/readiness/startup probes), resource limits и requests, HPA
настройку, secrets management через external-secrets-operator,
мониторинг через Prometheus.

Создай deployment manifest для Go-приложения с этими требованиями...
```

**Почему это нетривиально**: без явной роли модель может предложить упрощённый deployment без health checks или с некорректными resource limits. С ролью вы получаете production-ready конфигурацию.

**Реальный кейс**: без роли модель предложила `resources: {}`. С ролью DevOps-инженера — `requests: {memory: "128Mi", cpu: "100m"}, limits: {memory: "256Mi", cpu: "200m"}` с обоснованием значений.

### Few-shot Learning

Предоставление 2-4 примеров ожидаемого результата перед основным запросом. Модель учится на примерах и воспроизводит паттерн.

**Когда использовать**: специфичный стиль кода, уникальные паттерны вашей команды, DSL, миграции БД, конфигурационные файлы — когда "я знаю что хочу, но сложно описать словами".

**Пример для генерации миграций базы данных**:

```
Генерируй миграции Alembic в таком стиле:

# Пример 1 — добавление колонки:
def upgrade():
    op.add_column('users',
        sa.Column('email_verified', sa.Boolean(),
                  nullable=False, server_default='false'))
    op.create_index('idx_users_email_verified', 'users',
                    ['email_verified'], unique=False)

def downgrade():
    op.drop_index('idx_users_email_verified', table_name='users')
    op.drop_column('users', 'email_verified')

# Пример 2 — создание связи:
def upgrade():
    op.create_table('user_roles',
        sa.Column('user_id', sa.Integer(), nullable=False),
        sa.Column('role_id', sa.Integer(), nullable=False),
        sa.ForeignKeyConstraint(['user_id'], ['users.id'],
                                ondelete='CASCADE'),
        sa.ForeignKeyConstraint(['role_id'], ['roles.id'],
                                ondelete='CASCADE'),
        sa.PrimaryKeyConstraint('user_id', 'role_id')
    )
    op.create_index('idx_user_roles_user', 'user_roles', ['user_id'])

def downgrade():
    op.drop_index('idx_user_roles_user', table_name='user_roles')
    op.drop_table('user_roles')

Теперь создай миграцию: добавить таблицу sessions с полями
user_id (FK на users), token (string 255), expires_at (datetime),
индекс по token.
```

**Почему это нетривиально**: few-shot обходит проблему формализации правил. Вместо описания "создавай индексы для FK, используй ondelete, всегда пиши downgrade" — просто показываете примеры. Модель уловит паттерн точнее, чем из текстового описания.

### Prompt Chaining (Цепочка промптов)

Разбиение сложной задачи на последовательность простых запросов, где выход каждого — вход следующего.

**Когда использовать**: задачи, требующие анализа → проектирования → реализации. Вместо god-prompt "сделай всё" — контролируемая цепочка.

**Пример для рефакторинга легаси-кода на Go**:

```
Шаг 1: "Проанализируй функцию ProcessOrder() из order_handler.go.
Выдели все её обязанности. Перечисли списком."

Результат: валидация данных, проверка остатков на складе, расчёт
стоимости доставки, создание записи в БД, отправка email,
публикация события в Kafka.

Шаг 2: "Основываясь на списке, предложи декомпозицию на отдельные
функции согласно SRP. Дай название и сигнатуру каждой."

Результат: validateOrderData(order) error, checkInventory(items) error,
calculateShipping(address) (int, error), createOrderRecord(order) error,
sendOrderEmail(order) error, publishOrderEvent(order) error.

Шаг 3: "Реализуй validateOrderData() из предложенной декомпозиции.
Включи все проверки из оригинала: items не пустой, каждый item
с quantity > 0, address заполнен, payment_method валидный."

Шаг 4: "Перепиши ProcessOrder(), используя новые функции.
Сохрани исходное поведение — если любая функция вернёт ошибку,
откат транзакции и return error."

Шаг 5: "Создай table-driven unit-тесты для validateOrderData()
с testify. Кейсы: валидный заказ, пустой items, отрицательный quantity,
отсутствует address, невалидный payment_method."
```

**Почему это нетривиально**: сложные задачи требуют планирования. Одношаговый промпт приводит к поверхностным решениям или полной перезаписи с потерей логики. Chaining имитирует процесс опытного разработчика: понять → спланировать → реализовать → протестировать.

**Реальный кейс**: при рефакторинге 200-строчного метода без chaining модель предложила "разбить на 3 функции" и переписала 30% логики. С chaining — детальный анализ, 8 функций, сохранение всей логики, все edge cases покрыты.

### Self-Consistency (Самопроверка)

Агент проверяет свой результат по заданным критериям. Активирует режим критического анализа вместо генерации.

**Когда использовать**: критичный код — безопасность, производительность, деньги, параллелизм, асинхронность.

**Пример для Go-кода с горутинами**:

```typescript
После генерации кода с горутинами добавьте:

"Теперь проверь код на:
1. Race conditions — есть ли одновременный доступ к shared state без мьютексов
2. Goroutine leaks — все ли горутины гарантированно завершаются
3. Channel deadlocks — может ли возникнуть ситуация, когда все горутины
   ждут на каналах
4. Правильность использования context — проверяется ли context.Done() в циклах
5. Закрытие ресурсов — есть ли defer для Close()

Перечисли найденные проблемы. Для каждой предложи исправление."
```

**Почему это нетривиально**: модель хороша в поиске проблем, но может пропустить их при генерации. Явный запрос на проверку переключает режим мышления. Часто выявляет неочевидные баги.

**Реальный кейс**: сгенерированный код использовал `go func() { <-ch }()` в цикле без проверки закрытия канала. Self-consistency обнаружила: "При закрытии канала возникнет panic в горутинах" и предложила `for val := range ch`.

### Constraint Prompting (Жёсткие ограничения)

Явные ограничения на формат, структуру, содержание. Работает как виртуальный code reviewer.

**Когда использовать**: строгие code style guidelines, security requirements, архитектурные ограничения, enterprise-разработка с автоматическими проверками.

**Пример для TypeScript-проекта**:

```
Требования к коду:
- Все функции с явными типами параметров и возврата (no implicit any)
- Async функции всегда с try-catch или propagate errors
- Используй ?? вместо ||, optional chaining вместо && checks
- Имена: camelCase для переменных/функций, PascalCase для классов/типов
- Максимальная сложность функции (cyclomatic) — 8
- Не использовать any, unknown, as (кроме обоснованных случаев)
- Все публичные методы с JSDoc комментариями
- Для работы с датами — только date-fns, не moment
```

**Пример для безопасного Python-кода**:

```
Security constraints:
- Все SQL через parameterized queries (%, %s), никогда string concatenation
- Пароли только через bcrypt.hashpw с cost factor 12+
- Все user input через html.escape перед отображением
- API keys только через environment variables, никогда в коде
- Все file operations с явной проверкой path traversal (os.path.normpath)
- Rate limiting на всех публичных endpoints
```

**Почему это нетривиально**: предотвращает итерации для приведения кода к стандартам. Без constraints модель может предложить `user = db.execute(f"SELECT * FROM users WHERE id={id}")`. С constraints — `user = db.execute("SELECT * FROM users WHERE id = %s", (id,))`.

### Compositional Prompting (Композиция результатов)

Техника для больших задач: разделяете задачу на независимые части, получаете результаты параллельно, затем композируете.

**Когда использовать**: создание большой системы, где компоненты слабо связаны. Экономит время через параллелизм.

**Пример для REST API**:

```
Параллельно в разных сессиях:

Сессия 1: "Создай Pydantic модели для User API: UserCreate, UserUpdate,
UserResponse. Поля: id, email, username, created_at, is_active."

Сессия 2: "Создай SQLAlchemy модель User с теми же полями.
Таблица users, email уникальный, индекс по username."

Сессия 3: "Создай UserRepository с методами: get_by_id, get_by_email,
create, update, delete. Используй async SQLAlchemy."

Сессия 4: "Создай UserService с бизнес-логикой: register_user (валидация
email, хеширование пароля), update_profile, deactivate_user."

После получения всех результатов:

"Интегрируй компоненты: UserRepository использует SQLAlchemy модель,
UserService использует Repository, FastAPI endpoints используют Service
и Pydantic модели. Добавь dependency injection для Repository в Service."
```

**Почему это нетривиально**: при последовательной генерации каждый шаг зависит от предыдущего. При композиции — генерируете параллельно по спецификации, затем интегрируете. Ускорение в 3-4 раза для независимых компонентов.

## Антипаттерны промптинга

### 1. Нечёткие формулировки

**Проблема**: оценочные суждения и неопределённые требования.

**Плохо**: "Оптимизируй эту функцию", "Сделай код красивее", "Улучши производительность".

**Почему**: "Оптимизировать" = скорость? память? читаемость? размер кода? Модель выберет случайное направление.

**Хорошо**: "Оптимизируй функцию calculateStats() для массивов 100K+ элементов. Текущая проблема: O(n²) из-за вложенных циклов на строках 45-52. Цель: снизить до O(n log n) или O(n). Можно использовать дополнительную память O(n). Сохрани сигнатуру функции. Покрой изменения тестами с массивами 1K, 10K, 100K элементов."

**Реальный пример**: "сделай красиво" превратило `if (!user) return;` в 15 строк с паттерном null-object. "Убери дублирование в строках 34, 67, 102" — извлекло общую функцию.

### 2. God-Prompt (всё в одном)

**Проблема**: вся задача в одном огромном промпте.

**Плохо**: "Создай микросервис для обработки платежей с интеграцией Stripe, PostgreSQL для транзакций, Redis для кеширования, RabbitMQ для событий, REST API для фронтенда, GraphQL для мобильного приложения, admin-панель для мониторинга, JWT-аутентификацию, rate limiting, логирование, метрики Prometheus, написать unit и integration тесты, документацию OpenAPI и Docker Compose для развёртывания."

**Почему**: агент попытается всё сразу. Результат: поверхностная реализация, пропущенные детали, несогласованность между компонентами. Чем больше задач, тем ниже качество каждой.

**Хорошо**: разбить на этапы:
1. Спроектировать структуру: модули, зависимости, точки интеграции
2. Реализовать модели данных и database layer
3. Создать Stripe integration с error handling
4. Разработать API endpoints для core операций
5. Добавить RabbitMQ publisher для событий
6. Написать тесты для критичной логики (платежи, возвраты)
7. Настроить observability (логи, метрики)
8. Создать Docker Compose для local development

**Реальный кейс**: god-prompt на создание сервиса выдал 800 строк с заглушками "// TODO: implement retry logic". Поэтапный подход — полная реализация каждого компонента с тестами.

### 3. Отсутствие контекста

**Проблема**: запросы без стека, архитектуры, существующего кода.

**Плохо**: "Напиши функцию для аутентификации пользователя."

**Почему**: агент не знает: язык, фреймворк, где хранятся пользователи, схема БД, механизм аутентификации (JWT, sessions, OAuth), какие библиотеки уже в проекте. Результат несовместим с кодовой базой.

**Хорошо**: "В проекте на NestJS (TypeScript) с TypeORM и PostgreSQL реализуй метод для аутентификации. Используй сущность User (entities/user.entity.ts) с полями email и passwordHash. Пароли хешируются bcrypt (cost 12). Аутентификация через JWT: access token (15 мин) + refresh token (7 дней). Существует AuthModule и AuthService, добавь метод login(email, password) → {accessToken, refreshToken, userId}. При неверных credentials — throw UnauthorizedException."

**Реальный пример**: без контекста получили Django-код с sessions. С контекстом — NestJS с правильными декораторами, TypeORM entities, JWT из nestjs/jwt, соответствие проектной архитектуре.

## Промптинг для разных типов задач

Разные задачи требуют разных акцентов. Универсального промпта нет.

### Разработка: фокус на спецификации и тестируемости

**Шаблон**: Начните с интерфейса/контракта перед реализацией.

**Пример (Go)**: "Спроектируй и реализуй интерфейс CacheManager для работы с Redis. Методы: Get(ctx, key) (string, error), Set(ctx, key, value, ttl), Delete(ctx, key) error, Exists(ctx, key) bool. Используй go-redis/redis/v9. Автоматическая сериализация/десериализация JSON для Set/Get. Error handling: wrap errors через fmt.Errorf с %w, различай NotFound и network errors. Unit-тесты с miniredis для мока. Table-driven tests."

### Рефакторинг: акцент на сохранении поведения

**Шаблон**: Укажите конкретные code smells, подчеркните сохранение поведения.

**Пример (TypeScript)**: "Отрефактори класс OrderProcessor (src/order/processor.ts). Проблемы: метод process() 180 строк, вложенность if 6 уровней, дублирование валидации в 4 местах, нарушение SRP. Задачи: 1) Выдели методы-валидаторы с явными типами, 2) Разбей process() на методы по этапам: validate → calculate → persist → notify, 3) Извлеки magic numbers в enum, 4) Убери дублирование через helper-функции. КРИТИЧНО: сохрани все 27 существующих unit-тестов рабочими. Публичный API класса не менять."

### Тесты: требуйте edge cases и покрытие

**Шаблон**: Укажите фреймворк, типы тестов, конкретные сценарии.

**Пример (Python)**: "Напиши pytest unit-тесты для функции parse_duration(s: str) -> timedelta. Покрой: 1) валидные форматы '1h', '30m', '1h30m', '2d', 2) невалидные — пустая строка, 'abc', отрицательные значения, 3) edge cases — '0m', '999d', mixed case '1H30M', 4) whitespace — ' 1h ', '1h 30m'. Используй parametrize для группировки. Проверяй как значение result, так и тип exception для невалидных входов. Тесты должны проходить с coverage 100%."

### Документация: целевая аудитория + примеры

**Шаблон**: Укажите аудиторию, формат, требуйте примеры использования.

**Пример**: "Напиши API-документацию для WebSocket endpoint /api/v1/notifications в формате AsyncAPI 2.6. Включи: описание протокола, типы сообщений (subscribe, unsubscribe, notification), JSON schema для каждого типа, последовательность handshake, возможные ошибки (401, 429, 500), пример клиента на JavaScript с reconnect логикой, пример на Python с websockets lib. Аудитория — frontend и mobile разработчики без опыта WebSocket."

### Планирование: требуйте обоснование и альтернативы

**Шаблон**: Запрашивайте reasoning, trade-offs, сравнение подходов.

**Пример**: "Нужно спроектировать систему для обработки 50K событий/сек с гарантией exactly-once delivery. События из Kafka, обработка 100-500ms, результат в PostgreSQL. Требования: 1) Опиши архитектуру на Go с конкретными компонентами (consumer groups, workers, coordinator), 2) Объясни, как обеспечить exactly-once (Kafka даёт at-least-once), рассмотри idempotent consumers vs transactional outbox, 3) Покажи масштабирование при росте до 200K/сек, 4) Сравни trade-offs: простота vs производительность vs надёжность. Для каждого решения — аргументы за/против с примерами из практики."

---

Промптинг — навык, который развивается через эксперименты. Базовая структура: роль → контекст → задача → критерии. Продвинутые техники: few-shot для уникальных паттернов, chaining для сложных задач, self-consistency для критичного кода, constraints для стандартов. Избегайте нечёткости, god-промптов, отсутствия контекста. С опытом придёт интуиция, но принцип один: чем яснее задача, тем точнее результат.
