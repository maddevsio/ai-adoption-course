[← Оглавление](../../../README.md)

# Модуль 3: Промптинг — от вопросов к заданиям

> **Цель:** Формулировать задачи для агентов так, чтобы результат был готов к интеграции.

## 1. Сдвиг: вопрос → задание

Главное не трюки, а ментальная модель. Новичок воспринимает ИИ как поисковую систему. Эксперт — как исполнителя.

- **Вопрос** запрашивает информацию: "Как сделать JWT-авторизацию в FastAPI?" Вы получите общий ответ из документации. Его нужно адаптировать самостоятельно.
- **Задание** формулирует конкретную задачу: "Реализуй JWT-авторизацию для FastAPI. Модель User из models.py, эндпоинты /login и /refresh. Токен содержит user_id и роль. Access token — 15 минут, refresh — 7 дней." Вы получите код, готовый к интеграции.

Переход от вопросов к заданиям — это переход с уровня 1-2 на уровень 3+. От чат-кодинга к делегированию агенту.

## 2. Структура промпта для чатов и агентов

> [Диаграмма: Структура промпта — 4 блока](../diagrams/prompt-structure.md)

Промпт состоит из четырёх блоков.

### 2.1. Роль (Role) — кто выполняет задачу

Определяет компетенции агента. Не "ты программист", а конкретная экспертиза.

**Пример**: "Ты senior backend developer, специализируешься на Go и микросервисной архитектуре, глубоко понимаешь gRPC, Protocol Buffers и паттерны распределённых систем."

Явное указание экспертизы сдвигает вероятности к решениям с error handling, тестами — то, что пишут senior-разработчики.

> **Когда роль не нужна:** Для конкретных задач ("добавь эндпоинт /users с пагинацией") роль избыточна — задача сама задаёт контекст. Роль полезна в системных промптах, общих инструкциях и длинных сессиях, где она задаёт тон всей работе.

### 2.2. Контекст (Context) — в каких условиях

Контекст отвечает на вопросы:

- Какой язык и версия?
- Какие фреймворки?
- Какая архитектура?
- Что уже есть в проекте?
- Какие правила нельзя нарушать?

> **Для агентов:** Контекст должен показывать **ГДЕ** искать и **ЧТО** искать, а не **КАК** делать. Агент с доступом к кодовой базе сам найдёт нужные паттерны. Вместо "используй repository pattern с базовым классом BaseRepository" — лучше "посмотри существующие репозитории в `src/repositories/`, следуй тому же подходу".

### 2.3. Задача (Task) — что конкретно сделать

Конкретное действие, которое должен выполнить агент. Не "добавь функционал платежей", а детальная спецификация.

**Пример**:

```
Создай PaymentProcessor в services/payment.py.
Два метода: create_payment(user_id, amount, currency)
и check_payment_status(payment_id).
Используй StripeClient из lib/stripe_client.py.
Сохраняй транзакции через PaymentRepository.
При ошибках Stripe — rollback и логирование.
```

### 2.4. Критерии приёмки (Acceptance Criteria) — как понять, что готово

Условия, при которых задача считается выполненной. Чем точнее критерии, тем меньше итераций.

**Пример**:

```
Код должен:
1) проходить mypy без ошибок
2) покрываться pytest unit-тестами минимум 85%
3) включать моки для Stripe API
4) следовать black + isort для форматирования
5) обрабатывать все exceptions от Stripe с конкретными сообщениями
```

### Альтернатива: PPFO Framework

PPFO — другой подход к структурированию промпта:

- **Purpose** (Цель) — зачем нужна эта задача, какую проблему решает
- **Planning** (План) — последовательность шагов
- **Format** (Формат) — структура результата (файлы, архитектура, стиль)
- **Output** (Выход) — конкретные артефакты

**Пример PPFO-промпта**:

```
Purpose: Добавить rate limiting для защиты API от злоупотреблений.
Текущая проблема: нет ограничений на количество запросов, возможен DDoS.

Planning:
1. Реализовать middleware в TypeScript для Express
2. Использовать Redis для хранения счётчиков запросов
3. Настроить разные лимиты для ролей: анонимы 100 req/min,
   авторизованные 1000 req/min, admin без лимитов
4. Добавить заголовки X-RateLimit-Limit, X-RateLimit-Remaining

Format:
Express middleware с TypeScript типами, конфигурация через env variables,
injectable зависимости для тестируемости

Output:
middleware/rateLimiter.ts,
tests/rateLimiter.test.ts,
обновлённый app.ts с подключением middleware,
README с примерами использования и конфигурации
```

Четырёхблочная структура хороша для задач с большим контекстом. PPFO работает лучше для конкретных задач.

---

[← Чеклист готовности](../../module-2-tools/practice/03-checklist.md) | [Оглавление](../../../README.md) | [3. Продвинутые техники промптинга →](02-advanced-techniques.md)
