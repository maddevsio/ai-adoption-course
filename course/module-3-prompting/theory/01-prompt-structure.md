# Модуль 3: Промптинг — от вопросов к заданиям

> **Цель модуля:** Научиться формулировать задачи для ИИ-агентов так, чтобы получать результат, готовый к интеграции.

## 1. Ключевой сдвиг: вопрос → задание

Главное не трюки, а ментальная модель. Новичок воспринимает ИИ как поисковую систему, эксперт — как исполнителя.

**Вопрос** запрашивает информацию: "Как сделать JWT-авторизацию в FastAPI?" Вы получите общий ответ из документации, который нужно адаптировать самостоятельно. 
**Задание** формулирует конкретную задачу: "Реализуй JWT-авторизацию для FastAPI с использованием модели User из models.py, создай эндпоинты /login и /refresh, токен должен содержать user_id и роль, время жизни access token — 15 минут, refresh — 7 дней". Вы получите код, готовый к интеграции.

Переход от вопросов к заданиям — это переход с уровня 1-2 (чат-кодинг, копилот) на уровень 3+ (делегирование агенту).

## 2. Структура промпта для чатов и агентов

> [Диаграмма: Структура промпта — 4 блока](../diagrams/prompt-structure.md)

Эффективный промпт состоит из четырёх блоков. Каждый блок важен — пропуск может снизить качество результата.

### 2.1. Роль (Role) — кто выполняет задачу

Определяет компетенции агента. Не "ты программист", а конкретная экспертиза.

**Пример**: "Ты senior backend developer, специализируешься на Go и микросервисной архитектуре, глубоко понимаешь gRPC, Protocol Buffers и паттерны распределённых систем."

Явное указание экспертизы сдвигает вероятности к решениям с error handling, тестами — то, что пишут senior-разработчики.

> **Когда роль не нужна:** Для конкретных задач ("добавь эндпоинт /users с пагинацией") роль избыточна — задача сама задаёт контекст. Роль полезна в системных промптах, общих инструкциях и длинных сессиях, где она задаёт тон всей работе.

### 2.2. Контекст (Context) — в каких условиях

Контекст отвечает на вопросы: какой язык и версия, какие фреймворки, какая архитектура, что уже есть в проекте, какие правила нельзя нарушать.

> **Для агентов:** Контекст должен показывать **ГДЕ** искать и **ЧТО** искать, а не **КАК** делать. Агент с доступом к кодовой базе сам найдёт нужные паттерны. Вместо "используй repository pattern с базовым классом BaseRepository" — лучше "посмотри существующие репозитории в `src/repositories/`, следуй тому же подходу".

### 2.3. Задача (Task) — что конкретно сделать

Конкретное действие, которое должен выполнить агент. Не "добавь функционал платежей", а детальная спецификация.

**Пример**: "Создай PaymentProcessor в services/payment.py. Два метода: create_payment(user_id, amount, currency) и check_payment_status(payment_id). Используй StripeClient из lib/stripe_client.py, сохраняй транзакции через PaymentRepository. При ошибках Stripe — rollback и логирование."

### 2.4. Критерии приёмки (Acceptance Criteria) — как понять, что готово

Условия, при которых задача считается выполненной. Чем точнее критерии, тем меньше итераций.

**Пример**: "Код должен: 1) проходить mypy без ошибок, 2) покрываться pytest unit-тестами минимум 85%, 3) включать моки для Stripe API, 4) следовать black + isort для форматирования, 5) обрабатывать все exceptions от Stripe с конкретными сообщениями."

Для агентных инструментов промпт определяет цепочку действий: чтение файлов, генерация, запуск тестов, рефакторинг при ошибках.

### Альтернатива: PPFO Framework

PPFO — другой подход к структурированию промпта:

- **Purpose** (Цель) — зачем нужна эта задача, какую проблему решает
- **Planning** (План) — последовательность шагов
- **Format** (Формат) — структура результата (файлы, архитектура, стиль)
- **Output** (Выход) — конкретные артефакты

**Пример PPFO-промпта**:

```
Purpose: Добавить rate limiting для защиты API от злоупотреблений.
Текущая проблема: нет ограничений на количество запросов, возможен DDoS.

Planning:
1. Реализовать middleware в TypeScript для Express
2. Использовать Redis для хранения счётчиков запросов
3. Настроить разные лимиты для ролей: анонимы 100 req/min,
   авторизованные 1000 req/min, admin без лимитов
4. Добавить заголовки X-RateLimit-Limit, X-RateLimit-Remaining

Format:
Express middleware с TypeScript типами, конфигурация через env variables,
injectable зависимости для тестируемости

Output:
middleware/rateLimiter.ts,
tests/rateLimiter.test.ts,
обновлённый app.ts с подключением middleware,
README с примерами использования и конфигурации
```

Четырёхблочная структура (роль-контекст-задача-критерии) хорош для общих промптов, задач с большим контекстом и требованиями.

PPFO работает хорошо для конкретных задач.