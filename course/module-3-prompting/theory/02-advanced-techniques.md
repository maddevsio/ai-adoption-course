[← Оглавление](../../../README.md)

## 3. Продвинутые техники промптинга

Базовые техники (chain-of-thought, пошаговые инструкции) модели уже применяют сами. Фокусируемся на нетривиальных — тех, что модель сама не предложит.

### 3.1. Ролевая постановка (Role Assignment)

Задание конкретной роли с детализацией экспертизы направляет модель к профессиональным решениям.

**Когда использовать**: архитектурные решения, выбор паттернов, security-критичный код, рефакторинг, code review — везде, где важен опыт и понимание последствий.

**Пример для DevOps-задачи**:
```
Ты DevOps-инженер с 8-летним опытом работы с Kubernetes в production.
Знаешь best practices: zero-downtime deployments, proper health checks
(liveness/readiness/startup probes), resource limits и requests, HPA
настройку, secrets management через external-secrets-operator,
мониторинг через Prometheus.

Создай deployment manifest для Go-приложения с этими требованиями...
```

Без явной роли модель может предложить упрощённый deployment без health checks или с `resources: {}`. С ролью — `requests: {memory: "128Mi", cpu: "100m"}, limits: {memory: "256Mi", cpu: "200m"}` с обоснованием значений.

---

### 3.2. Few-shot Learning

Предоставление 2-4 примеров ожидаемого результата перед основным запросом. Модель учится на примерах и воспроизводит паттерн.

**Когда использовать**: специфичный стиль кода, уникальные паттерны вашей команды, DSL, миграции БД, конфигурационные файлы — когда "я знаю что хочу, но сложно описать словами".

**Пример для генерации миграций базы данных**:

```
Генерируй миграции Alembic в таком стиле:

# Пример — добавление колонки:
def upgrade():
    op.add_column('users',
        sa.Column('email_verified', sa.Boolean(),
                  nullable=False, server_default='false'))
    op.create_index('idx_users_email_verified', 'users',
                    ['email_verified'], unique=False)

def downgrade():
    op.drop_index('idx_users_email_verified', table_name='users')
    op.drop_column('users', 'email_verified')

Теперь создай миграцию: добавить таблицу sessions с полями
user_id (FK на users), token (string 255), expires_at (datetime),
индекс по token.
```

Few-shot обходит проблему формализации правил. Вместо описания "создавай индексы для FK, используй ondelete, всегда пиши downgrade" — просто показываете примеры. Модель уловит паттерн точнее, чем из текстового описания.

---

### 3.3. Prompt Chaining (Цепочка промптов)

> [Диаграмма: Prompt Chaining — цепочка промптов](../diagrams/prompt-chaining.md)

Разбиение сложной задачи на последовательность простых запросов, где выход каждого — вход следующего.

**Когда использовать**: задачи, требующие анализа → проектирования → реализации. Вместо god-prompt "сделай всё" — контролируемая цепочка.

**Пример для рефакторинга легаси-кода**:

```
Шаг 1: "Проанализируй ProcessOrder() из order_handler.go.
Выдели все обязанности списком."

Шаг 2: "Предложи декомпозицию на функции по SRP.
Дай название и сигнатуру каждой."

Шаг 3: "Реализуй каждую функцию. Перепиши ProcessOrder()
с их использованием — при ошибке rollback и return error."

Шаг 4: "Напиши table-driven тесты для validateOrderData()."
```

Сложные задачи требуют планирования. Одношаговый промпт приводит к поверхностным решениям. Chaining имитирует процесс опытного разработчика: понять → спланировать → реализовать → протестировать.

---

### 3.4. Self-Consistency (Самопроверка)

Агент проверяет свой результат по заданным критериям. Активирует режим критического анализа вместо генерации.

**Когда использовать**: критичный код — безопасность, производительность, деньги, параллелизм, асинхронность.

**Пример**: после генерации кода добавьте запрос на проверку:

```
"Проверь этот код на: race conditions, goroutine leaks,
channel deadlocks, правильность context.Done() в циклах,
defer для Close(). Перечисли проблемы с исправлениями."
```

Модель хороша в поиске проблем, но может пропустить их при генерации. Явный запрос на проверку переключает режим мышления.

> **Совет:** Запускайте ревью в отдельном чате или другой моделью. У каждой LLM свои слепые пятна — разные модели замечают ошибки друг друга.

---

### 3.5. Constraint Prompting (Жёсткие ограничения)

Явные ограничения на формат, структуру, содержание. Работает как виртуальный code reviewer.

**Когда использовать**: строгие code style guidelines, security requirements, архитектурные ограничения.

**Пример для TypeScript-проекта**:

```
Требования к коду:
- Все функции с явными типами параметров и возврата (no implicit any)
- Async функции всегда с try-catch или propagate errors
- Используй ?? вместо ||, optional chaining вместо && checks
- Не использовать any, unknown, as (кроме обоснованных случаев)
```

---

### 3.6. Compositional Prompting (Композиция результатов)

Техника для больших задач: разделяете задачу на независимые части, получаете результаты параллельно, затем композируете.

**Когда использовать**: создание большой системы, где компоненты слабо связаны. Экономит время через параллелизм.

> **Важно:** Каждая сессия должна оставлять артефакт — документ, схему, решение. Следующая сессия начинается с чтения этого артефакта и продолжает работу. Без этого контекст теряется между сессиями.

**Пример для REST API**:

```
Параллельно в разных сессиях:

Сессия 1: "Создай Pydantic модели для User API: UserCreate, UserUpdate,
UserResponse. Поля: id, email, username, created_at, is_active."

Сессия 2: "Создай SQLAlchemy модель User с теми же полями.
Таблица users, email уникальный, индекс по username."

Сессия 3: "Создай UserRepository с методами: get_by_id, get_by_email,
create, update, delete. Используй async SQLAlchemy."

Сессия 4: "Создай UserService с бизнес-логикой: register_user (валидация
email, хеширование пароля), update_profile, deactivate_user."

После получения всех результатов:

"Интегрируй компоненты: UserRepository использует SQLAlchemy модель,
UserService использует Repository, FastAPI endpoints используют Service
и Pydantic модели. Добавь dependency injection для Repository в Service."
```

При последовательной генерации каждый шаг зависит от предыдущего. При композиции — генерируете параллельно по спецификации, затем интегрируете. Ускорение в 3-4 раза для независимых компонентов.
---

[← Модуль 3: Промптинг — от вопросов к заданиям](01-prompt-structure.md) | [Оглавление](../../../README.md) | [4. Антипаттерны промптинга →](03-antipatterns.md)
