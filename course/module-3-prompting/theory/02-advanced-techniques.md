[← Оглавление](../../../README.md)

## 3. Продвинутые техники промптинга

Базовые техники (chain-of-thought, пошаговые инструкции) модели применяют сами. Ниже — нетривиальные.

### 3.1. Ролевая постановка (Role Assignment)

Конкретная роль с детализацией экспертизы направляет модель к профессиональным решениям.

**Когда использовать:**
- Архитектурные решения, выбор паттернов
- Security-критичный код
- Рефакторинг и code review
- Везде, где важен опыт и понимание последствий

**Пример для DevOps-задачи**:
```
Ты DevOps-инженер с 8-летним опытом работы с Kubernetes в production.
Знаешь best practices: zero-downtime deployments, proper health checks
(liveness/readiness/startup probes), resource limits и requests, HPA
настройку, secrets management через external-secrets-operator,
мониторинг через Prometheus.

Создай deployment manifest для Go-приложения с этими требованиями...
```

Без явной роли модель может предложить упрощённый deployment без health checks или с `resources: {}`. С ролью результат будет содержать `requests`, `limits` и обоснование значений.

---

### 3.2. Few-shot Learning

Предоставление 2-4 примеров ожидаемого результата перед основным запросом. Модель учится на примерах и воспроизводит паттерн.

**Когда использовать:**
- Специфичный стиль кода, уникальные паттерны команды
- DSL, миграции БД, конфигурационные файлы
- Когда "я знаю что хочу, но сложно описать словами"

**Пример для генерации миграций базы данных**:

```
Генерируй миграции Alembic в таком стиле:

# Пример — добавление колонки:
def upgrade():
    op.add_column('users',
        sa.Column('email_verified', sa.Boolean(),
                  nullable=False, server_default='false'))
    op.create_index('idx_users_email_verified', 'users',
                    ['email_verified'], unique=False)

def downgrade():
    op.drop_index('idx_users_email_verified', table_name='users')
    op.drop_column('users', 'email_verified')

Теперь создай миграцию: добавить таблицу sessions с полями
user_id (FK на users), token (string 255), expires_at (datetime),
индекс по token.
```

Few-shot обходит проблему формализации правил. Вместо описания всех правил словами — показываете примеры. Модель сама выведет паттерн.

---

### 3.3. Prompt Chaining (Цепочка промптов)

> [Диаграмма: Prompt Chaining — цепочка промптов](../diagrams/prompt-chaining.md)

Разбиение сложной задачи на последовательность простых запросов, где выход каждого — вход следующего.

**Когда использовать:** задачи, требующие анализа, проектирования, реализации. Вместо god-prompt "сделай всё" — контролируемая цепочка.

**Пример для рефакторинга легаси-кода**:

```
Шаг 1: "Проанализируй ProcessOrder() из order_handler.go.
Выдели все обязанности списком."

Шаг 2: "Предложи декомпозицию на функции по SRP.
Дай название и сигнатуру каждой."

Шаг 3: "Реализуй каждую функцию. Перепиши ProcessOrder()
с их использованием — при ошибке rollback и return error."

Шаг 4: "Напиши table-driven тесты для validateOrderData()."
```

Одношаговый промпт приводит к поверхностным решениям. Chaining воспроизводит процесс эксперта: понять, спланировать, реализовать, протестировать.

---

### 3.4. Self-Consistency (Самопроверка)

Агент проверяет свой результат по заданным критериям.

**Когда использовать:** критичный код — безопасность, финансы, параллелизм, асинхронность.

**Пример**: после генерации кода добавьте запрос на проверку:

```
"Проверь этот код на: race conditions, goroutine leaks,
channel deadlocks, правильность context.Done() в циклах,
defer для Close(). Перечисли проблемы с исправлениями."
```

Модель хороша в поиске проблем, но может пропустить их при генерации.

> **Совет:** Запускайте ревью в отдельном чате или другой моделью. У каждой LLM свои слепые пятна — разные модели замечают ошибки друг друга.

---

### 3.5. Constraint Prompting (Жёсткие ограничения)

Явные ограничения на формат, структуру, содержание.

**Когда использовать**: строгие code style guidelines, security requirements, архитектурные ограничения.

**Пример для TypeScript-проекта**:

```
Требования к коду:
- Все функции с явными типами параметров и возврата (no implicit any)
- Async функции всегда с try-catch или propagate errors
- Используй ?? вместо ||, optional chaining вместо && checks
- Не использовать any, unknown, as (кроме обоснованных случаев)
```

---

### 3.6. Compositional Prompting (Композиция результатов)

Разделяете задачу на независимые части. Получаете результаты параллельно. Затем композируете.

**Когда использовать:** создание большой системы со слабо связанными компонентами. Экономит время через параллелизм.

> **Важно:** Каждая сессия должна оставлять артефакт — документ, схему, решение. Следующая сессия начинается с чтения этого артефакта. Без этого контекст теряется между сессиями.

**Пример для REST API**:

```
Параллельно в разных сессиях:

Сессия 1: "Создай Pydantic модели для User API: UserCreate, UserUpdate,
UserResponse. Поля: id, email, username, created_at, is_active."

Сессия 2: "Создай SQLAlchemy модель User с теми же полями.
Таблица users, email уникальный, индекс по username."

Сессия 3: "Создай UserRepository с методами: get_by_id, get_by_email,
create, update, delete. Используй async SQLAlchemy."

Сессия 4: "Создай UserService с бизнес-логикой: register_user (валидация
email, хеширование пароля), update_profile, deactivate_user."

После получения всех результатов:

"Интегрируй компоненты: UserRepository использует SQLAlchemy модель,
UserService использует Repository, FastAPI endpoints используют Service
и Pydantic модели. Добавь dependency injection для Repository в Service."
```

Ускорение в 3-4 раза для независимых компонентов.

---

[← Модуль 3: Промптинг — от вопросов к заданиям](01-prompt-structure.md) | [Оглавление](../../../README.md) | [4. Антипаттерны промптинга →](03-antipatterns.md)
