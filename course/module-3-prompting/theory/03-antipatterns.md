## 4. Антипаттерны промптинга

### 4.1. Нечёткие формулировки

**Плохо**: "Оптимизируй эту функцию", "Сделай код красивее", "Улучши производительность".

"Оптимизировать" = скорость? память? читаемость? размер кода? Модель выберет случайное направление.

**Хорошо**: "Оптимизируй функцию calculateStats() для массивов 100K+ элементов. Текущая проблема: O(n²) из-за вложенных циклов на строках 45-52. Цель: снизить до O(n log n) или O(n). Можно использовать дополнительную память O(n). Сохрани сигнатуру функции. Покрой изменения тестами с массивами 1K, 10K, 100K элементов."

> Если лень писать/генерить промпт, можно использовать skill (writing-plans, debugging и прочие), которые заставляют агента задавать уточняющие вопросы, если что-то непонятно
---

### 4.2. God-Prompt (всё в одном)

> [Диаграмма: God-Prompt vs Декомпозиция](../diagrams/god-prompt-vs-decomposition.md)

**Плохо**: "Создай микросервис для обработки платежей с интеграцией Stripe, PostgreSQL для транзакций, Redis для кеширования, RabbitMQ для событий, REST API для фронтенда, GraphQL для мобильного приложения, admin-панель для мониторинга, JWT-аутентификацию, rate limiting, логирование, метрики Prometheus, написать unit и integration тесты, документацию OpenAPI и Docker Compose для развёртывания."

Агент попытается всё сразу. Результат: поверхностная реализация, пропущенные детали, несогласованность между компонентами.

**Хорошо** — разбить на этапы:
1. Спроектировать структуру: модули, зависимости, точки интеграции
2. Реализовать модели данных и database layer
3. Создать Stripe integration с error handling
4. Разработать API endpoints для core операций
5. Добавить RabbitMQ publisher для событий
6. Написать тесты для критичной логики (платежи, возвраты)
7. Настроить observability (логи, метрики)
8. Создать Docker Compose для local development

---

### 4.3. Отсутствие контекста

**Плохо**: "Напиши функцию для аутентификации пользователя."

Агент не знает: язык, фреймворк, где хранятся пользователи, схема БД, механизм аутентификации (JWT, sessions, OAuth), какие библиотеки уже в проекте. Результат несовместим с кодовой базой.

**Хорошо**: "В проекте на NestJS (TypeScript) с TypeORM и PostgreSQL реализуй метод для аутентификации. Используй сущность User (entities/user.entity.ts) с полями email и passwordHash. Пароли хешируются bcrypt (cost 12). Аутентификация через JWT: access token (15 мин) + refresh token (7 дней). Существует AuthModule и AuthService, добавь метод login(email, password) → {accessToken, refreshToken, userId}. При неверных credentials — throw UnauthorizedException."

---

### 4.4. Отсутствие критериев приёмки

**Плохо**: "Добавь фильтрацию задач по статусу."

Агент реализует что-то, но у него нет способа проверить себя. Нет ожидаемого поведения, нет граничных случаев, нет определения "готово". Результат может не соответствовать ожиданиям, а агент не поймёт, что ошибся.

**Хорошо**: "Добавь фильтрацию задач по статусу. Критерии приёмки:
- `GET /tasks?status=pending` → только задачи со статусом pending
- `GET /tasks?status=invalid` → 400 с описанием допустимых значений
- `GET /tasks` (без параметра) → все задачи, поведение не меняется
- Добавь тесты на все три сценария. Запусти тесты после реализации."

> [!IMPORTANT]
> Критерии приёмки — способ для агента проверить себя. Без них он не знает, когда задача выполнена. С ними — может верифицировать каждый пункт и итерировать до полного соответствия.
