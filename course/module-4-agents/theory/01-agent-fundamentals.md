[← Оглавление](../../../README.md)

# Модуль 4: Работа с AI-агентом

## 1. От консультанта к исполнителю

Главное различие между чатом и агентом не в модели, которая лежит в основе, а в способе взаимодействия и уровне автономности.

**Чат** работает в режиме вопрос-ответ. 

Q: "Как реализовать JWT-авторизацию в FastAPI?"
A: пример кода и объяснение. 

Код нужно скопировать, адаптировать к проекту, протестировать самостоятельно. Чат не имеет доступа к файлам проекта, не видит структуру кодовой базы, не может запустить тесты. Это справочная система с интерфейсом на естественном языке.

**Агент** работает в режиме постановки задачи. 

Q: "Реализуй JWT-авторизацию для FastAPI с использованием модели User из models.py, добавь тесты с покрытием 80%+". 
A: читает models.py, анализирует существующий код, пишет новые файлы, запускает тесты, итерирует при ошибках, и возвращает работающее решение.

Это не консультант — это исполнитель.

Агент работает в цикле **plan → act → observe → adjust**. Он планирует последовательность действий, выполняет их, наблюдает результат, корректирует подход при необходимости. Этот цикл продолжается до выполнения критериев приёмки или достижения лимита итераций.

> [Диаграмма: Цикл работы агента (Agent Loop)](../diagrams/agent-loop.md)

Полезная аналогия: **чат — это Stack Overflow с интерактивным интерфейсом**, агент — это **джуниор-разработчик**, которому вы ставите задачу. Джуниору нужен контекст, чёткая постановка задачи, критерии приёмки, и ваша ответственность — проверить результат перед мержем в main.

## 2. Постановка задачи: от проблемы к плану

Эффективная работа с агентом начинается с правильной декомпозиции задачи. Большие задачи агенты выполняют хуже, чем последовательность маленьких.

Вместо "Добавь систему уведомлений в проект" эффективнее разбить на подзадачи. Каждая подзадача — атомарна, проверяема, имеет чёткие границы. Декомпозицией может заниматься умный агент-планировщик.

**Агент-планировщик** — вы описываете проблему в общем виде, и агент в режиме планирования предлагает **Plan** (документ с последовательностью шагов, файлами для изменения и порядком выполнения). 

Вы ревьюите план, корректируете, проверяете план другим агентом, и только после одобрения плана агент переходит к реализации.

Контекст критичен. Агент не знает структуру проекта, архитектурные решения, code conventions — нужно явно указать, где это можно узнать. 

Минимальный контекст для задачи: где лежат файлы, какие зависимости уже установлены, какие паттерны использовать (например, "все API endpoints используют async/await и FastAPI dependency injection"), какие ограничения учитывать ("не изменяй существующую схему БД, только добавляй новые таблицы").

Критерии приёмки превращают размытую задачу в проверяемую. Вместо "код должен работать" используйте конкретные критерии: 1) все тесты проходят (pytest без ошибок), 2) линтер чист (flake8, mypy), 3) покрытие тестами минимум 80% (coverage report)

Тесты — ключевой инструмент приёмки. Агент должен пройти все виды тестов (unit, integration, E2E) прежде чем результат попадёт на ревью. 

ИИ радикально снижает стоимость написания тестов. Поэтому покрытие должно быть высоким, а E2E тесты — не привилегия, а необходимость. Подробнее — в [тестирование с агентами](03-testing-with-agents.md).

**TDD-подход** (Test-Driven Development — сначала тесты, потом код) особенно хорош для агентской разработки: тесты становятся спецификацией, которую агент обязан выполнить

## 3. Режимы работы: планирование и исполнение

Ключевое разделение в работе с агентами — режимы **Plan** и **Act/Execute**. Это не просто две фазы одной задачи, это разные режимы мышления с разными требованиями к модели, бюджету токенов, и уровню вашего контроля.

> [Диаграмма: Режимы Plan vs Act](../diagrams/plan-vs-act.md)

**Plan (режим планирования)**: агент анализирует задачу, исследует кодовую базу, формирует план действий — но **не вносит изменений**. 

Результат этой фазы — документ с последовательностью шагов, списком файлов для изменения, предполагаемым подходом к решению.

**Act/Execute (режим исполнения)**: агент (скорее всего другой агент с чистым контекстным окном) реализует утверждённый план, итерирует при ошибках до выполнения критериев приёмки. Агент должен быть автономен: не спрашивает разрешения на каждое действие, принимает решения в рамках плана.

Разделение режимов даёт три преимущества:

1. **Проверка плана до изменений**: вы видите, что агент собирается делать, и можете скорректировать до того, как написаны сотни строк кода

2. **Оптимизация затрат**: планирование требует "умной" дорогой модели (Claude Opus). Исполнение часто можно делегировать более дешёвой модели (Claude Sonnet).

3. **Предотвращение дрейфа**: без явного плана агент может "уйти не туда" — начать рефакторить смежный код, переписывать архитектуру, внедрять паттерны, которые вы не просили. План ограничивает scope работы.

**Steering (управление направлением)** расширяет концепцию Plan/Act на несколько checkpoint'ов. Вместо одного большого запроса "Реализуй фичу X" используется цепочка: **research → plan → implement → verify**. Каждый checkpoint — точка проверки и корректировки.

Пример steering для задачи "Добавить систему кеширования в API":

1. **Research**: "Изучи текущую архитектуру API (routes, controllers, services). Какие endpoints самые медленные (проверь логи или профилирование)? Какие библиотеки для кеширования уже используются?"
2. **Plan**: "На основе исследования предложи план внедрения кеширования: какие endpoints кешировать, где хранить кэш (Redis, in-memory), как инвалидировать"
3. **Implement**: "Реализуй план: создай cache service, добавь middleware для кеширования, обнови нужные endpoints."
4. **Verify**: "Запусти тесты. Проверь через curl, что кэш работает. Убедись, что инвалидация срабатывает при изменении данных."

На каждом крупном этапе вы проверяете вывод агента и можете скорректировать следующий шаг. Steering особенно эффективен для задач с высокой неопределённостью, где финальное решение зависит от найденной в процессе информации.

## 4. AGENTS.md: конституция проекта

Агенты не имеют памяти между сессиями. Каждая новая сессия начинается с чистого листа. 

**AGENTS.md** — это файл-инструкция в корне проекта, который агент читает перед началом работы. Это **конституция**: набор правил и принципов, которые агент обязан соблюдать.

**Примечание о названиях:** В разных инструментах используются разные названия для этого файла: `AGENTS.md`, `CLAUDE.md`, `.cursorrules`. Суть одна — правила работы агента с проектом.

> [Диаграмма: Структура AGENTS.md](../diagrams/agents-md-structure.md)

Что содержит AGENTS.md:

**1. Stack**: точные версии, чтобы агент генерировал совместимый код. Не просто "используем FastAPI", а "FastAPI 0.104.1

**2. Conventions**: именование файлов, структура директорий, code style. Пример: "Модели БД в models/, API endpoints в routes/, бизнес-логика в services/."

**3. Rules**: обязательные паттерны. "Все SQL-запросы через SQLAlchemy ORM, никаких raw queries."

**4. Forbidden**: что агент не должен делать. "НЕ изменяй схему БД без обсуждения"

**5. Before Starting Work**: инструкции для первого шага. "Перед любой задачей: 1) прочитай AGENTS.md (этот файл), 2) прочитай docs/architecture.md"

Claude Code может сгенерить CLAUDE.md автоматически 
```
claude init
```

**Эволюция AGENTS.md**: файл не статичен. По мере работы вы обнаруживаете, что агент повторяет одни и те же ошибки. Каждая такая ошибка — сигнал обновить AGENTS.md. 

В **Enji Fleet** используется паттерн **traces → constitution**: агенты оставляют notes после каждой задачи (что сделано, какие проблемы, какие решения), а специализированный агент в reflect-mode консолидирует эти знания в constitution раз в неделю. Это предотвращает случайную поломку constitution одним агентом.
---

[← Упражнение 3: Игра Gandalf (15 мин)](../../module-3-prompting/practice/03-gandalf.md) | [Оглавление](../../../README.md) | [5. Human-in-the-loop vs Agentic mass generation →](02-hitl-and-quality.md)
