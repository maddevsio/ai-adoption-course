[← Оглавление](../../../README.md)

# Модуль 4: Работа с AI-агентом

## 1. От консультанта к исполнителю

Чат отвечает на вопросы. Агент выполняет задачи: читает файлы, пишет код, запускает тесты, итерирует.

**Чат** работает в режиме вопрос-ответ. 

Q: "Как реализовать JWT-авторизацию в FastAPI?"
A: пример кода и объяснение. 

Код нужно скопировать, адаптировать к проекту, протестировать самостоятельно. Чат не видит файлы проекта и не может запустить тесты. По сути, это справочная система с интерфейсом на естественном языке.

**Агент** работает в режиме постановки задачи. 

Q: "Реализуй JWT-авторизацию для FastAPI с использованием модели User из models.py, добавь тесты с покрытием 80%+".
A: читает models.py, анализирует код, пишет новые файлы, запускает тесты, итерирует при ошибках. Возвращает работающее решение.

Агент работает в цикле **plan -> act -> observe -> adjust**. Он планирует действия, выполняет их, наблюдает результат, корректирует подход. Цикл продолжается до выполнения критериев приёмки или достижения лимита итераций.

> [Диаграмма: Цикл работы агента (Agent Loop)](../diagrams/agent-loop.md)

Джуниору нужен контекст, чёткая постановка, критерии приёмки — и ваша ответственность проверить результат.

## 2. Постановка задачи: от проблемы к плану

Большие задачи агенты выполняют хуже последовательности маленьких.

Вместо "Добавь систему уведомлений в проект" эффективнее разбить на подзадачи. Каждая подзадача атомарна, проверяема, имеет чёткие границы. Декомпозицией может заниматься агент-планировщик.

**Агент-планировщик** -- вы описываете проблему в общем виде. Агент предлагает **Plan**: документ с последовательностью шагов, файлами для изменения и порядком выполнения.

Вы ревьюите план, корректируете, проверяете другим агентом. Только после одобрения агент переходит к реализации.

Агент не знает структуру проекта, архитектурные решения, code conventions. Нужно явно указать, где это можно узнать.

**Минимальный контекст для задачи:**
- **Расположение файлов** и установленные зависимости
- **Паттерны** -- например, "все API endpoints используют async/await и FastAPI dependency injection"
- **Ограничения** -- например, "не изменяй существующую схему БД, только добавляй новые таблицы"

**Критерии приёмки** должны быть конкретными. Вместо "код должен работать":
1. Все тесты проходят (pytest без ошибок)
2. Линтер чист (flake8, mypy)
3. Покрытие тестами минимум 80% (coverage report)

**Тесты** -- ключевой инструмент приёмки. Агент должен пройти все виды тестов (unit, integration, E2E) прежде чем результат попадёт на ревью.

ИИ снижает стоимость написания тестов. Покрытие должно быть высоким, а E2E тесты -- не привилегия, а необходимость. Подробнее в [тестирование с агентами](03-testing-with-agents.md).

**TDD-подход** (сначала тесты, потом код) особенно хорош для агентской разработки. Тесты становятся спецификацией, которую агент обязан выполнить.

## 3. Режимы работы: планирование и исполнение

Ключевое разделение в работе с агентами -- режимы **Plan** и **Act/Execute**. Это разные режимы мышления с разными требованиями к модели, бюджету токенов и уровню контроля.

> [Диаграмма: Режимы Plan vs Act](../diagrams/plan-vs-act.md)

**Plan (режим планирования)**: агент анализирует задачу, исследует кодовую базу, формирует план действий -- но **не вносит изменений**. Результат -- документ со списком шагов, файлов для изменения и подходом к решению.

**Act/Execute (режим исполнения)**: агент реализует утверждённый план, итерирует при ошибках до выполнения критериев приёмки. Обычно это другой агент с чистым контекстным окном. Агент автономен: не спрашивает разрешения на каждое действие, принимает решения в рамках плана.

Разделение режимов даёт три преимущества:

1. **Проверка плана до изменений**

2. **Оптимизация затрат**: Opus для планирования, Sonnet для исполнения

3. **Предотвращение дрейфа**: план ограничивает scope

**Steering (управление направлением)** расширяет концепцию Plan/Act на несколько checkpoint'ов. Вместо одного большого запроса "Реализуй фичу X" используется цепочка: **research -> plan -> implement -> verify**. Каждый checkpoint -- точка проверки и корректировки.

<details>
<summary>Пример steering: "Добавить систему кеширования в API"</summary>

1. **Research**: "Изучи текущую архитектуру API (routes, controllers, services). Какие endpoints самые медленные? Какие библиотеки для кеширования уже используются?"
2. **Plan**: "Предложи план: какие endpoints кешировать, где хранить кэш (Redis, in-memory), как инвалидировать"
3. **Implement**: "Реализуй план: создай cache service, добавь middleware, обнови endpoints"
4. **Verify**: "Запусти тесты. Проверь через curl, что кэш работает. Убедись, что инвалидация срабатывает"

</details>

На каждом этапе вы проверяете вывод агента и корректируете следующий шаг. Steering особенно эффективен для задач с высокой неопределённостью.

## 4. AGENTS.md: конституция проекта

Агенты не имеют памяти между сессиями.

**AGENTS.md** -- файл-инструкция в корне проекта. Агент читает его перед началом работы. Это **конституция**: набор правил и принципов, которые агент обязан соблюдать.

> [Диаграмма: Структура AGENTS.md](../diagrams/agents-md-structure.md)

Что содержит AGENTS.md:

- **Stack** -- точные версии, чтобы агент генерировал совместимый код. Не "используем FastAPI", а "FastAPI 0.104.1"
- **Conventions** -- именование файлов, структура директорий, code style
- **Rules** -- обязательные паттерны. Например: "Все SQL-запросы через SQLAlchemy ORM, никаких raw queries"
- **Forbidden** -- что агент не должен делать. Например: "НЕ изменяй схему БД без обсуждения"
- **Before Starting Work** -- инструкции для первого шага. Например: "Прочитай AGENTS.md, потом docs/architecture.md"

Claude Code может сгенерить CLAUDE.md автоматически 
```
claude init
```

**Эволюция AGENTS.md**: файл не статичен. Каждая повторяющаяся ошибка агента — сигнал обновить AGENTS.md.

---

[← Упражнение 3: Игра Gandalf (15 мин)](../../module-3-prompting/practice/03-gandalf.md) | [Оглавление](../../../README.md) | [5. Human-in-the-loop vs Agentic mass generation →](02-hitl-and-quality.md)
