# Context Engineering на практике: обязательные артефакты агентов

Дополнительный материал к Модулю 5. Разбираем реальную систему контекст-инжиниринга из проекта **Enji Fleet** — как агенты обязаны оставлять артефакты, и почему без этого проект разваливается.

## Зачем нужны обязательные артефакты

AI-агент не имеет памяти между сессиями. Это не метафора — это буквальное ограничение. Каждая новая сессия начинается с чистого контекстного окна. Без артефактов происходит следующее:

1. **Потеря решений.** Агент принимает архитектурное решение (какой логгер, какой паттерн DI, где хранить миграции) — но не фиксирует его. Следующий агент принимает другое решение. Через 3 сессии в проекте 3 разных подхода к одной задаче.

2. **Повторение ошибок.** Агент сталкивается с проблемой (race condition, неправильная обработка ошибок) и решает её. Следующий агент в похожей задаче наступает на те же грабли — потому что решение нигде не записано.

3. **Деградация качества.** Без зафиксированных стандартов каждый агент "оптимизирует на скорость" — делает как проще, не как правильно. Checkpoint "smoke test проходит" обходится тремя строками curl, а не полноценной проверкой CRUD.

Артефакты решают эту проблему: **то, что не записано — не существует для следующей сессии**.

## Иерархия артефактов

Артефакты образуют иерархию от стратегического уровня (constitution) до тактического (traces, fails):

```
Constitution (правила, ADR, паттерны)
    ↑ консолидация (reflect-mode)
Plans (что делать: задачи, порядок, критерии)
    ↓ выполнение (dev-mode)
Traces (что сделано: решения, проблемы, находки)
    ↓ анализ инцидентов
Fails (что пошло не так: root cause, prevention)
```

Каждый уровень решает свою задачу:

| Артефакт | Назначение | Когда создаётся | Кто читает |
|----------|-----------|-----------------|------------|
| Constitution | Правила и стандарты проекта | Обновляется из traces | Все агенты перед работой |
| Plan | Задачи конкретной итерации | Перед началом работы | Агент-исполнитель |
| Trace | Лог выполнения плана | Во время и после работы | Reflect-mode агент |
| Fail | Постмортем инцидента | После обнаружения проблемы | Все агенты |

## Constitution: живой документ проекта

Constitution — это не README и не документация для людей. Это **справочник для агентов**: компактный документ (~400-500 строк), который агент обязан прочитать перед любой работой.

### Что содержит Constitution

**1. Tech Stack с точными версиями:**

```markdown
| Component | Technology | Version | Notes |
|-----------|------------|---------|-------|
| Language | Go | 1.24 | go.mod toolchain go1.24.13 |
| Database | PostgreSQL | 15+ | Метаданные всех сервисов |
| Cache | Redis | 7+ | Agent Service (worker sessions) |
| Logging | **zap** | v1.27 | **Единый стандарт** (см. ADR-001) |
```

Не "используем Go" — а "Go 1.24, toolchain go1.24.13". Не "PostgreSQL" — а "PostgreSQL 15+". Точность предотвращает несовместимость.

**2. Architecture Decision Records (ADR):**

```markdown
### ADR-001: Единый логгер — zap

**Контекст:** Store Service использует zap, Credentials Service использует slog.
Разные библиотеки создают несовместимый формат логов.

**Решение:** Использовать zap через `shared/pkg/logger` для всех сервисов.

**Причины:**
- zap уже в shared — переиспользуем, не дублируем
- Быстрее slog в бенчмарках
- Единый формат упрощает агрегацию (ELK/Loki)

**Статус:** Выполнено (Plans 005, 012, 014).
```

ADR фиксируют **почему** принято решение, а не только **что** решено. Следующий агент видит контекст и не пытается "улучшить" выбор.

**3. Обязательные паттерны и антипаттерны.**

**4. Quick commands** — как собрать, запустить, протестировать.

### Правило защиты Constitution

> Агенты **НЕ пишут** в constitution напрямую. Предложения идут в секцию "Для конституции" в trace. Consolidation — в reflect-mode.

Это критически важно. Если каждый агент будет править constitution напрямую:
- Параллельные агенты создадут merge conflicts
- Один агент может случайно удалить важное правило
- Документ распухнет без контроля качества

Вместо этого: агенты предлагают изменения через traces, а специальный reflect-mode агент решает, что попадёт в constitution.

## Plans: пронумерованные, последовательные, самодостаточные

Plans — это **единицы работы** для агентов. Каждый план — самодостаточный документ, который содержит всё необходимое для выполнения задачи.

### Структура плана

```
docs/plans/
├── 001-mvp-project-structure.plan.md
├── 002-mvp-store-service.plan.md
├── ...
├── 022-execution-flow-e2e.plan.md
└── 023-agent-pipeline-quality.plan.md
```

Нумерация обеспечивает порядок выполнения. Агент не начинает Plan 023, пока Plan 022 не завершён.

Типичный план содержит:

```markdown
# Plan 022: Execution Flow E2E

status: in_progress
Prerequisites: Plan 020, Plan 021

## Tasks

| # | Задача | Статус | Файлы |
|---|--------|--------|-------|
| 1 | Stage-per-worker lifecycle | done | task/internal/service/ |
| 2 | Flow-aware task acquisition | done | task/internal/repository/ |
| 3 | Trigger normalization | done | agent/internal/domain/ |

## Checkpoints

- CP-1: Unit tests pass (go test ./...)
- CP-2: Integration test: task → worker → completion
- CP-3: No orphaned containers after test run
```

### Почему планы важны для агентов

1. **Контекст одним файлом.** Агент читает план и понимает: что делать, в каком порядке, какие файлы менять, как проверить.
2. **Scope ограничен.** Агент не уходит "рефакторить всё" — план определяет границы работы.
3. **Progress tracking.** Статусы задач показывают, что уже сделано (для текущего или следующего агента).

## Traces: обязательный артефакт после работы

Trace — это **лог выполнения плана**. Не просто "что сделано", а полный контекст: решения, проблемы, находки, предложения.

### Шаблон trace (из Enji Fleet)

```markdown
# Trace: <plan-name>

**Дата:** YYYY-MM-DD
**План:** [NNN-plan-name.plan.md](../plans/NNN-plan-name.plan.md)
**Агент:** <имя агента: Claude, Codex, Gemini, etc.>
**Статус:** completed | partial | failed

## Что сделано

- Краткий список выполненных задач

## Что узнал

- Технические детали, которые не очевидны из кода
- Как запускать, какие команды
- Какие порты, зависимости

## Проблемы

- Что не работало
- Как решил

## Технические решения

Отклонения от плана/спеки с обоснованием.

| # | Решение | Причина |
|---|---------|---------|
| D-xxx | ... | ... |

## Техдолг

Новый техдолг, обнаруженный или созданный. Формат: что, почему, приоритет.

## Для конституции

Что стоит перенести в constitution:
- Tech stack детали
- Паттерны
- Антипаттерны
- Lessons learned
```

### Каждая секция решает свою задачу

**"Что сделано"** — краткий отчёт для контроля прогресса. Не роман, а список:

```markdown
- TASK-1: DB Migrations — 000007 rename, add columns
- TASK-2: Domain model — WorkerState enum, transition validation
- TASK-3: Repository — UpdateStatus with retry_count increment
```

**"Что узнал"** — знания, которые не очевидны из кода:

```markdown
- Task Service Create() устанавливает current_stage из entry stage flow
- Port 8005 занят Agent Service, не использовать для Runtime
- gRPC маппинг ошибок: InvalidArgument/NotFound/FailedPrecondition
```

Это самая ценная секция. Код показывает *что* сделано, но не *почему* или *как это работает в runtime*.

**"Проблемы"** — что пошло не так и как решил:

```markdown
- gRPC handler тесты не доведены до 85%: отсутствует helper `stringPtr`,
  нужно прогнать goimports
- Spawner создаёт контейнеры в бесконечном цикле — retry_count не
  инкрементируется из-за вызова UpdateTaskStatus вместо ReleaseTask
```

**"Технические решения"** — отклонения от плана в табличном формате:

```markdown
| # | Решение | Причина |
|---|---------|---------|
| D-030 | ResolveAcquireFilters итерирует только static flows | Custom flows — chicken-and-egg problem |
| D-031 | AcquireTask repo принимает statuses+stages | Separation of concerns: repo = SQL executor |
```

Таблица позволяет быстро просканировать решения без чтения длинного текста.

**"Для конституции"** — предложения на обновление constitution:

```markdown
- Зафиксировать требование Go toolchain 1.24.x
- Добавить паттерн: buf lint BASIC с отключением PACKAGE_DIRECTORY_MATCH
- Антипаттерн: не использовать UpdateTaskStatus для финальных переходов
```

Это входные данные для reflect-mode. Агент-ревьюер читает эту секцию из всех traces и решает, что добавить в constitution.

### Правило инкрементального заполнения

> Обновляйте trace **инкрементально** — после каждой находки или исправления записывайте сразу. Не накапливайте в памяти.

Если агент записывает trace только в конце сессии, он забудет детали. Инкрементальная запись гарантирует полноту.

## Fails: постмортемы как обязательные артефакты

Fails — это **постмортемы инцидентов**. Когда что-то идёт не так, агент создаёт документ с анализом причин и мерами предотвращения.

### Реальный пример: расхождение паттернов между сервисами

Из файла `docs/fails/2026-02-07-cross-plan-consistency.md`:

**Что произошло:** Агент реализовал 3 плана в отдельных сессиях. Каждый план выполнен качественно, но между сервисами возникли системные расхождения:

| Аспект | Store Service | Credentials Service |
|--------|--------------|---------------------|
| Logger | `zap` (shared/pkg/logger) | `slog` (internal/logging) |
| Миграции | `backend/migrations/` | `credentials/migrations/` |
| DI | Интерфейсы (mockable) | Конкретные типы (не mockable) |

**Root cause:** Constitution на момент реализации была почти пустой — шаблон с placeholder'ами. Агент прочитал её, но не нашёл конкретных указаний.

**Contributing factors:**
- Промпт не обязывал обновлять constitution (было "опционально")
- Нет памяти между сессиями — решения Plan 002 не передались в Plan 003
- Аудит после трёх планов, а не после каждого — расхождения накопились
- Checkpoint "smoke test проходит" обходится тремя строками curl

**Lessons learned:**
- **Constitution — не шаблон, а инструмент.** Пустая constitution = каждый агент решает сам
- **"Опционально" для агента = "не делать".** Важное — пишите "ОБЯЗАТЕЛЬНО"
- **Checkpoint должен быть machine-checkable.** Не "smoke test проходит", а "Create → ID, Get → object, Delete → 404"
- **Ревью по одному плану дешевле, чем пачкой**

### Реальный пример: E2E blockers

Из файла `docs/fails/2026-02-12-qa-e2e-blockers.md`:

При первом E2E прогоне система не смогла довести ни одну задачу до завершения. Найдено 7 багов, 2 из которых CRITICAL:

- **CLI name deadlock** — Agent Service и SDK использовали разные имена для CLI tools. Ни одно имя не проходило обе валидации. Ни один Claude-агент не мог запуститься.
- **Бесконечный respawn** — Spawner создавал контейнеры в цикле, потому что retry_count не инкрементировался в БД. 17 мёртвых контейнеров за 2 минуты.

Без постмортемов эти ошибки повторились бы. С постмортемами — следующий агент читает `docs/fails/` перед работой и знает, что проверять.

### Структура fail-документа

```markdown
# Postmortem: <название инцидента>

**Дата:** YYYY-MM-DD
**Серьёзность:** HIGH | MEDIUM | LOW
**Статус:** mitigated | resolved | open

## Что произошло
Краткое описание проблемы.

## Почему произошло
### Root cause
Главная причина.

### Contributing factors
Что усугубило ситуацию.

## Impact
Прямые и косвенные последствия.

## Что сделано для предотвращения
Конкретные изменения в коде, процессе, документации.

## Lessons learned
Выводы для будущих агентов.
```

## Цикл накопления знаний

Артефакты образуют замкнутый цикл:

```
1. Агент читает: constitution → plan → fails
2. Агент работает: реализует задачи по плану
3. Агент пишет trace: что сделано, что узнал, проблемы, решения
4. Reflect-mode читает traces: извлекает "Для конституции"
5. Reflect-mode обновляет constitution: добавляет паттерны, ADR, lessons
6. Следующий агент читает обновлённую constitution
```

### Reflect-mode: агент-консолидатор

Reflect-mode — это специальный режим работы, в котором агент:
- **НЕ пишет код** (нет доступа к инструментам разработки)
- Читает traces от других агентов
- Извлекает секции "Для конституции"
- Консолидирует знания: сжимает, дедуплицирует, структурирует
- Обновляет constitution и decisions
- Выявляет повторяющиеся проблемы → добавляет в антипаттерны

Разделение ролей (dev-mode пишет код, reflect-mode пишет constitution) защищает главный артефакт от хаотичных изменений.

## Как внедрить систему артефактов в свой проект

### Уровень 1: Минимальный (для старта)

1. Создайте `AGENTS.md` в корне проекта (constitution)
2. Заведите директорию `docs/traces/`
3. После каждой сессии с агентом просите его создать trace
4. Раз в неделю читайте traces и обновляйте AGENTS.md

### Уровень 2: Структурированный (для активной разработки)

1. Constitution с ADR, паттернами, антипаттернами
2. `docs/plans/` — нумерованные планы работ
3. `docs/traces/` — traces по шаблону с обязательными секциями
4. `docs/fails/` — постмортемы инцидентов
5. Правило: агент не начинает работу без прочтения constitution

### Уровень 3: Полный (для оркестрации нескольких агентов)

1. Всё из уровня 2
2. Reflect-mode для консолидации знаний
3. `docs/specs/` — спецификации фич (что строить)
4. `docs/decisions.md` — decision log с state machines
5. `docs/guides/` — руководства по написанию спецификаций и планов
6. Workflow modes: dev-mode, doc-mode, reflect-mode, test-e2e
7. Правило: constitution обновляется только через reflect-mode

### Реальные цифры из Enji Fleet

Для ориентира — объём артефактов в реальном проекте (7 микросервисов + фронтенд):

| Артефакт | Количество | Общий объём |
|----------|-----------|-------------|
| Plans | 23 файла | ~32,000 строк |
| Traces | 43 файла | ~6,200 строк |
| Fails | 7 файлов | ~600 строк |
| Specs | 17 файлов | ~8,000 строк |
| Constitution | 1 файл | ~800 строк |
| Decisions | 1 файл | ~700 строк |

Constitution — самый компактный документ, но самый важный. Traces — самый объёмный, но быстро теряющий актуальность (ценность — в консолидации в constitution).

## Блокирующие правила для агентов

Система артефактов работает только если агенты **обязаны** их создавать. "Опционально" = "не делать".

### Правила из Enji Fleet

```markdown
# Блокирующие правила (из dev-mode промпта)

**СТОП и исправь:**
- Тест падает → исправь код, пока тест не пройдёт
- go vet ошибки → исправь все
- Coverage ниже минимума → добавь тесты
- Build падает → исправь, пока не соберётся

**ЗАПРЕЩЕНО:**
- Переходить к следующей задаче при ошибках
- Код без тестов
- Пропускать заполнение trace
- Писать в constitution напрямую (только через trace)

**ОБЯЗАТЕЛЬНО:**
- Прочитать constitution перед началом работы
- Прочитать docs/fails/ для предотвращения повторных ошибок
- Заполнить trace инкрементально (не в конце сессии)
- Обновить Progress Table в плане
```

### Формулировки имеют значение

| Плохо | Хорошо |
|-------|--------|
| "Опционально обнови constitution" | "Заполни секцию 'Для конституции' в trace — ОБЯЗАТЕЛЬНО" |
| "Smoke test проходит" | "Smoke test: Create → ID, Get → object, Delete → 404" |
| "Напиши тесты" | "Каждый endpoint покрыт минимум 1 integration тестом. Coverage > 80%" |
| "Задокументируй решения" | "Таблица технических решений в trace: # | Решение | Причина" |

Агент оптимизирует на скорость. Чем конкретнее требование, тем выше вероятность его выполнения.

## Практическое задание

### Упражнение 1: Создайте систему артефактов для своего проекта

1. Создайте структуру директорий:
```bash
mkdir -p docs/plans docs/traces docs/fails
```

2. Создайте constitution (или дополните существующий AGENTS.md) — включите:
   - Tech stack с версиями
   - Минимум 2 ADR (архитектурных решения)
   - Минимум 3 обязательных паттерна
   - Минимум 3 антипаттерна

3. Создайте первый план (даже если простой):
```markdown
# Plan 001: <название>
## Tasks
| # | Задача | Статус |
|---|--------|--------|
| 1 | ... | pending |
```

### Упражнение 2: Напишите trace по шаблону

1. Выполните любую задачу с помощью агента
2. Попросите агента создать trace по шаблону из этого материала
3. Проверьте: все ли секции заполнены? Есть ли конкретика в "Что узнал"? Есть ли предложения в "Для конституции"?

### Упражнение 3: Напишите постмортем

Вспомните случай, когда что-то пошло не так в вашем проекте (баг, неправильное решение, потеря данных). Напишите fail-документ:
- Что произошло?
- Почему? (root cause)
- Как предотвратить в будущем?

Даже если вы не используете агентов — этот документ поможет следующему разработчику (или вам через полгода).

## Резюме

- **Артефакты обязательны**, не опциональны. "Опционально" для агента = "не делать"
- **Иерархия:** Constitution → Plans → Traces → Fails. Каждый уровень решает свою задачу
- **Constitution защищена:** агенты не пишут напрямую, предлагают через traces
- **Traces заполняются инкрементально** — не в конце сессии
- **Fails предотвращают повторение** — root cause + prevention measures
- **Цикл:** работа → trace → reflect-mode → constitution → следующая работа
- **Блокирующие правила** гарантируют выполнение. Конкретные формулировки > общие пожелания
- **Начните с малого:** AGENTS.md + traces. Добавляйте уровни по мере роста проекта

---

## Источники

- [Context Engineering for AI Agents](https://www.linkedin.com/pulse/context-engineering-ai-agents-tobi-lutke/) — Tobi Lutke (CEO Shopify)
- [Building a C compiler with parallel Claudes](https://www.anthropic.com/engineering/building-c-compiler) — Anthropic Engineering
- [AGENTS.md specification](https://agents.md/) — открытый стандарт для AI-агентов
- Enji Fleet internal documentation — Mad Devs
