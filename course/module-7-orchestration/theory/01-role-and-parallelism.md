# Модуль 7: Параллельные агенты и оркестрация

## 1. От кодера к архитектору оркестра

На этом уровне происходит фундаментальный сдвиг в роли разработчика. Кодинг не исчезает, но перестаёт быть основной деятельностью.

**Три компетенции:**

1. **Проектирование** — писать спецификации, которые агенты могут автономно исполнить. Вместо того, чтобы писать код, вы пишете описание того, каким этот код должен быть.

2. **Менеджмент оркестратора** — настраивать роли агентов, выбирать модели под задачи (умная модель планирует, дешёвая кодит), управлять стратегиями (когда перезапускать, когда менять агентов).

3. **Контроль качества** — приёмка результатов, code review PR-ов от агентов, мониторинг метрик (время выполнения, количество итераций, расход токенов).

Кодинг остаётся там, где агенты не справляются: сложная бизнес-логика без чёткой спецификации, интеграции с недокументированными API, архитектурные решения, отладка нетривиальных багов. Но объём ручного кодинга радикально снижается.

## 2. Зачем нужна параллельность

Один агент = одна задача (Йегге ур. 5) 

Агент делает последовательно задачу за задачей, но агент неавтономен. Агент нуждается в постановке задачи, направлении, фидбэке.

Несколько агентов = несколько задач одновременно. (Йегге ур. 6-7) 

Один агент работает над фронтендом, другой — над бэкендом, третий пишет тесты. Те же задачи выполняются быстрее. Но агенты все еще надеются на человека, который ведет их к цели.

> [Диаграмма: Параллельная работа в двух терминалах](../diagrams/terminal-split.md)

**Когда параллельность оправдана:**
- Фича состоит из 5+ независимых подзадач
- Задачи не блокируют друг друга
- Есть бюджет на несколько параллельных сессий

**Когда параллельность избыточна:**
- Маленькая задача (один баг, один endpoint)
- Задачи сильно связаны (нужен результат первой для начала второй)
- Первый раз делаете что-то новое — сначала проверьте на одном агенте

Честно про overhead: параллельность добавляет сложность. Нужно изолировать контексты, разрешать конфликты при слиянии, мониторить несколько процессов. Ценность проявляется в масштабе: когда нужно сделать 10 фич, а не одну.

Следующий уровень (Йегге ур. 8):
Оркестратор = иерархическая система из агентов принимает на себя задачи, выполняет их, дотаскивает до конца, тестирует, ревьюит. Разработчик нужен для обслуживания, отладки, указания стратегии

```
                    ┌──────────────┐
                    │  Разработчик │
                    │  (человек)   │
                    └──────┬───────┘
                           │ задачи + стратегия
                    ┌──────▼───────┐
                    │ Оркестратор  │
                    │ (Opus/GPT-5) │
                    └──────┬───────┘
              ┌────────────┼────────────┐
              │            │            │
       ┌──────▼──────┐ ┌──▼───────┐ ┌──▼──────────┐
       │ Планировщик │ │Ресёрчер  │ │ QA/Ревьюер  │
       │  (Sonnet)   │ │(Sonnet)  │ │  (Sonnet)   │
       └──────┬──────┘ └──────────┘ └─────────────┘
              │ подзадачи
    ┌─────────┼─────────┐
    │         │         │
┌───▼───┐ ┌──▼────┐ ┌──▼────┐
│Dev #1 │ │Dev #2 │ │Dev #3 │
│(Haiku)│ │(Haiku)│ │(Haiku)│
└───────┘ └───────┘ └───────┘
```

**Плюсы оркестратора:**
- Масштаб: 10+ задач параллельно, человек только контролирует
- Специализация: каждый агент оптимизирован под свою роль и стоимость
- Автономность: цепочка Research → Plan → Implement → Review работает без ручного вмешательства
- Воспроизводимость: playbook можно переиспользовать на аналогичных задачах

**Минусы и сложности:**
- Инфраструктура: нужно настроить credential management, мониторинг, систему очередей задач
- Стоимость координации: оркестратор-агент тратит токены на планирование, распределение, проверку — это overhead поверх полезной работы
- Отладка: когда что-то ломается в цепочке из 5 агентов, найти причину сложнее, чем в одном агенте
- Нестабильность: агенты могут галлюцинировать, зацикливаться, конфликтовать — нужны механизмы перезапуска и fallback
- Порог входа: требуется время на создание playbook-ов, настройку ролей, калибровку промптов