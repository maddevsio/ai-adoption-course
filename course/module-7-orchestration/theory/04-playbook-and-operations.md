## 7. "Библия" и Playbook оркестратора

**"Библия"** — надстройка над конституцией. Верхнеуровневый ценностный документ проекта, который определяет контекст для флита агентов: целевые пользователи, типы задач, стандарты качества, процессы деплоя, тон коммуникации. Разные проекты = разные библии.

**Playbook** — формализованный флоу работы для агентов. Markdown-документ с чеклистом задач, который агент (или оркестратор) выполняет последовательно, отмечая выполненные пункты.

Ключевая идея: playbook — это не просто план, а **исполняемый документ**. Каждый пункт — конкретное действие с критерием завершения. Агент читает чеклист сверху вниз, выполняет задачу, ставит `[x]` и переходит к следующей.

**Структура playbook:**

```markdown
# Playbook: [название]

## Цель
[Что делаем и зачем]

## Подзадачи

### 1. Backend: API endpoint
- [ ] Создать GET /api/users/export endpoint
- [ ] Реализовать генерацию CSV
- [ ] Написать тесты: успешный экспорт, пустой список, спецсимволы
- [ ] Запустить тесты, убедиться что всё зелёное

### 2. Frontend: кнопка Export
- [ ] Добавить кнопку "Export to CSV" в таблицу
- [ ] Реализовать скачивание файла
- [ ] Обработать ошибки, добавить loader
- [ ] Запустить тесты

### 3. E2E тесты (после задач 1 и 2)
- [ ] Написать тест: создать данные → Export → проверить CSV
- [ ] Написать негативный тест
- [ ] Запустить полный набор тестов

## Процедура слияния
- [ ] Merge backend → main
- [ ] Merge frontend → main, разрешить конфликты в package.json
- [ ] Merge e2e → main
- [ ] Финальный прогон всех тестов
```

Формат `- [ ]` / `- [x]` — не просто визуальное удобство. Это машиночитаемый прогресс: оркестратор или человек видит, на каком этапе задача, что сделано, что осталось.

### 7.1. Оркестратор на практике: Maestro

[Maestro](https://maestro.dev) — десктопное приложение для оркестрации флота AI-агентов. Поддерживает Claude Code, Codex, OpenCode, Factory Droid. Ключевая идея: вы пишете спецификации, Maestro исполняет их агентами автоматически.

```
┌─────────────────────────────────────────────────────────┐
│                      MAESTRO                            │
│                                                         │
│  ┌─────────────┐    ┌──────────────────────────────┐    │
│  │  Playbooks/ │    │         Auto Run Engine      │    │
│  │             │    │                              │    │
│  │ deploy.md   │───>│  1. Читает playbook          │    │
│  │ migrate.md  │    │  2. Берёт первый - [ ]       │    │
│  │ feature.md  │    │  3. Создаёт свежую сессию    │    │
│  │             │    │  4. Отправляет задачу агенту │    │
│  └─────────────┘    │  5. Ждёт завершения          │    │
│                     │  6. Ставит - [x]             │    │
│                     │  7. Следующий - [ ]          │    │
│                     │  8. Все сделано? → Runs/log  │    │
│                     └──────────┬───────────────────┘    │
│                                │                        │
│              ┌─────────────────┼─────────────────┐      │
│              │                 │                 │      │
│        ┌─────▼──────┐   ┌──────▼──────┐   ┌─────▼─────┐ │
│        │ Сессия #1  │   │ Сессия #2   │   │ Сессия #3 │ │
│        │ Claude Code│   │ Codex       │   │ OpenCode  │ │
│        │            │   │             │   │           │ │
│        │ worktree/  │   │ worktree/   │   │ worktree/ │ │
│        │ feat-api   │   │ feat-ui     │   │ feat-test │ │
│        └────────────┘   └─────────────┘   └───────────┘ │
│              │                │                 │       │
│              └────────► git merge ◄─────────────┘       │
│                           │                             │
│                     ┌─────▼─────┐                       │
│                     │   main    │                       │
│                     └───────────┘                       │
└─────────────────────────────────────────────────────────┘
```

### 7.2. Auto Run: исполнение playbook-ов

Auto Run — движок, который берёт папку с markdown-документами и прогоняет их через агентов.

**Процесс исполнения:**
1. Выбираете папку с playbook-ами
2. Auto Run берёт первый документ, читает чеклист сверху вниз
3. Каждая задача `- [ ]` отправляется агенту в свежей сессии
4. Агент выполняет задачу, Auto Run ставит `- [x]`
5. Документы без невыполненных задач пропускаются
6. Прогресс: "Document 2 of 5, Task 3 of 8"

**Изоляция сессий** — критическое свойство. Каждая задача выполняется в чистой сессии с уникальным session ID. Нет истории предыдущих задач, нет протекания контекста. Агент подходит к каждой задаче без памяти о предыдущей работе. Это делает поведение детерминированным — один и тот же playbook даёт одинаковый результат при повторном запуске.

Без изоляции агент накапливает контекст от предыдущих задач. К 10-й задаче контекстное окно забито артефактами первых девяти, агент путается, галлюцинирует, замедляется. Изоляция решает это: каждая задача — чистый старт.

**Очередь документов** — можно добавить несколько playbook-ов в очередь, менять порядок drag-and-drop, дублировать документы для повторного исполнения.

**Loop Mode** — после завершения последнего документа Auto Run возвращается к первому. Сценарий: playbook "проверь мониторинг → найди аномалии → создай issue" крутится непрерывно. С Reset on Completion каждая итерация начинается с чистого чеклиста.

**Reset on Completion** — оригинальный playbook сохраняется как шаблон. Исполнение создаёт копию в `Runs/` подпапке с таймстампом (например, `TASK-1735192800000-loop-1.md`). Каждый прогон — отдельный артефакт-аудитлог: что было сделано, когда, каким агентом.

**Остановка и продолжение** — при нажатии Stop текущая задача завершается (не обрывается), прогресс сохраняется. Можно продолжить с того же места кнопкой Run.

### 7.3. Параллельная работа через worktrees

Maestro создаёт отдельного суб-агента для каждого worktree. Суб-агенты отображаются вложенными под родительским агентом, у каждого своя рабочая директория, история и состояние.

Типичный сценарий: Auto Run исполняет playbook в одном worktree, пока вы интерактивно работаете с агентом в другом. Три агента пишут три фичи параллельно — без конфликтов, потому что файловые системы изолированы.

Maestro умеет отслеживать worktrees, созданные снаружи (через CLI), и автоматически подключать их.

### 7.4. Group Chat: координация между агентами

Для задач, где агенты должны общаться друг с другом, Maestro реализует **Group Chat** — мультиагентный чат с модератором.

**Как работает:**
1. Модератор (отдельный агент) управляет дискуссией
2. Участники подключаются через @mention: `@backend-agent`, `@frontend-agent`
3. Модератор получает вопрос, делегирует нужным агентам
4. Агенты отвечают в контексте своих проектов
5. Модератор синтезирует ответы и возвращает результат

Модератор не возвращается к вам, пока вопрос не получит полный ответ — он будет ходить к агентам столько раз, сколько нужно.

Пример: "Агент backend, какой формат ответа у endpoint /api/users? Агент frontend, совпадает ли он с тем, что ты ожидаешь?" → модератор получает оба ответа, находит расхождение, просит агентов согласовать контракт.

### 7.5. Wizard: генерация playbook-а из диалога

Вместо ручного написания playbook-а можно сгенерировать его через `/wizard`:

1. Описываете задачу в свободной форме
2. AI задаёт уточняющие вопросы
3. Индикатор уверенности растёт по мере понимания требований
4. При 80%+ уверенности AI генерирует готовый playbook с чеклистом
5. Playbook сохраняется в отдельную подпапку

Wizard полезен для задач, где вы не знаете, как правильно декомпозировать. AI уже видел тысячи подобных задач и предложит разумную структуру.

Ссылка: https://docs.runmaestro.ai/autorun-playbooks

### 7.6. Пример расчёта стоимости оркестрированного workflow

Для задачи "Добавить систему уведомлений" с 3 агентами:

| Этап | Модель | Токены (input/output) | Стоимость |
|------|--------|-----------------------|-----------|
| Планирование | Opus 4.6 ($5/$25 за 1M) | 30K / 20K | ~$0.65 |
| Агент 1: API + Email | Sonnet 4.5 ($3/$15 за 1M) | 80K / 40K | ~$0.84 |
| Агент 2: SMS | Sonnet 4.5 ($3/$15 за 1M) | 60K / 30K | ~$0.63 |
| Агент 3: UI | Haiku 4.5 ($1/$5 за 1M) | 100K / 50K | ~$0.35 |
| Ревью | Opus 4.6 ($5/$25 за 1M) | 50K / 10K | ~$0.50 |
| **Итого** | | **~470K токенов** | **~$2.97** |

> [!NOTE] Это оценка при работе по API. При подписке ($100-200/мес) стоимость не считается потокенно — вы используете лимиты подписки. Расчёт полезен для понимания экономики: мульти-модельная стратегия (дорогая модель для планирования, дешёвая для исполнения) снижает стоимость в 2-3 раза по сравнению с использованием Opus для всех этапов.

## 8. Мониторинг и конфликты

### 8.1. Мониторинг агентов

**Метрики для отслеживания:**

| Метрика | Что показывает |
|---------|---------------|
| Время на задачу (median, p95) | Сколько в среднем агент тратит на атомарную задачу |
| Количество итераций до успеха | Сколько раз агент прогонял цикл Do→Check→Fix |
| Расход токенов | Сколько стоила задача |
| Процент успешных завершений | Сколько задач доведено до PR без ручного вмешательства |

Если агент с профилем X плохо справляется с задачами типа Y — сменить модель, улучшить промпт, переназначить другому агенту.

### 8.2. Конфликты при слиянии результатов

Два агента изменили один файл — классический merge conflict. Как разрешить:

1. **Ручное ревью** — человек объединяет изменения. Для критичного кода.
2. **Агент-арбитр** — третий агент читает оба варианта и предлагает решение. Для простых конфликтов.
3. **Повторный запуск** — откатываем одного агента и перезапускаем с учётом изменений другого.

Лучшая стратегия — предотвращение конфликтов на этапе планирования: разделяйте работу по разным файлам/модулям.

### 8.3. Lessons learned: эволюция знаний

**Три типа памяти:**

1. **Состояние работы** (git-based) — что сделано, что осталось. Коммиты, PR, issue tracking.
2. **Контекст проекта** (артефакты) — архитектура, стек, принятые решения. Хранится в `docs/constitution.md`.
3. **Знания по самоулучшению** (lessons → skills) — переносимая память между проектами. Агент решил сложный баг → записал lesson → lesson попадает в constitution → следующий агент не совершит ту же ошибку.

## 9. Честно про сложности

**Первое время медленнее.** Первые недели вы потратите больше времени на настройку, отладку, разрешение конфликтов. Ценность не в первой задаче, а в масштабе.

**Нужна инфраструктура.** бюджет агентов (по подписке + бесплатные), credential management, мониторинг — всё требует первоначальной настройки.

**Стоимость.** Использование LLM по API с оплатой за каждый токен слишком затратно, избегайте этого. Нужно взять несколько подписок и бесплатных сервисов и крутить их до достижения лимитов. При грамотной эксплуатации лимитов подписок, затраты должны быть не выше з/п обычного разработчика

**Когда оркестратор уместен:**
- Проект с хорошим тестовым покрытием и CI — агенты могут автоматически проверять свою работу
- Задача декомпозируется на 5+ независимых подзадач с чёткими критериями приёмки
- Повторяющиеся задачи одного типа (миграция 20 сервисов, обновление API в 15 клиентах)
- Проект с устоявшейся архитектурой и конвенциями, описанными в constitution
- Команда уже освоила работу с одним агентом и упирается в пропускную способность

**Трудные сценарии для оркестратора:**
- Проект имеет низкую толерантность к рискам и багам (жизненно важная инфраструктура, медицинские аппараты и т.д.)
- Исследовательская задача со множеством неизвестных. Сначала нужно сделать ресерч, написать спеку, а потом идти реализовывать через оркестратор
- Legacy код с без тестов и документации. Переезд на разработку через оркестратор будет болезненным из-за обилия контекста, тех долга
