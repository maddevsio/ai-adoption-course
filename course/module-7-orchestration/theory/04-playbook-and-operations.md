[← Оглавление](../../../README.md)

## 7. "Библия" и Playbook оркестратора

**"Библия"** — надстройка над конституцией. Определяет контекст для флита агентов: целевые пользователи, типы задач, стандарты качества, процессы деплоя. Разные проекты = разные библии.

**Playbook** — markdown-документ с чеклистом задач. Каждый пункт — действие с критерием завершения. Агент выполняет сверху вниз, отмечает `[x]`.

**Структура playbook:**

```markdown
# Playbook: [название]

## Цель
[Что делаем и зачем]

## Подзадачи

### 1. Backend: API endpoint
- [ ] Создать GET /api/users/export endpoint
- [ ] Реализовать генерацию CSV
- [ ] Написать тесты: успешный экспорт, пустой список, спецсимволы
- [ ] Запустить тесты, убедиться что всё зелёное

### 2. Frontend: кнопка Export
- [ ] Добавить кнопку "Export to CSV" в таблицу
- [ ] Реализовать скачивание файла
- [ ] Обработать ошибки, добавить loader
- [ ] Запустить тесты

### 3. E2E тесты (после задач 1 и 2)
- [ ] Написать тест: создать данные → Export → проверить CSV
- [ ] Написать негативный тест
- [ ] Запустить полный набор тестов

## Процедура слияния
- [ ] Merge backend → main
- [ ] Merge frontend → main, разрешить конфликты в package.json
- [ ] Merge e2e → main
- [ ] Финальный прогон всех тестов
```

Формат `- [ ]` / `- [x]` — машиночитаемый прогресс: оркестратор или человек видит, что сделано и что осталось.

### 7.1. Оркестратор на практике: Maestro

[Maestro](https://maestro.dev) — десктопное приложение для оркестрации флота AI-агентов. Поддерживает Claude Code, Codex, OpenCode, Factory Droid. Вы пишете спецификации, Maestro исполняет их агентами.

```
┌─────────────────────────────────────────────────────────┐
│                      MAESTRO                            │
│                                                         │
│  ┌─────────────┐    ┌──────────────────────────────┐    │
│  │  Playbooks/ │    │         Auto Run Engine      │    │
│  │             │    │                              │    │
│  │ deploy.md   │───>│  1. Читает playbook          │    │
│  │ migrate.md  │    │  2. Берёт первый - [ ]       │    │
│  │ feature.md  │    │  3. Создаёт свежую сессию    │    │
│  │             │    │  4. Отправляет задачу агенту │    │
│  └─────────────┘    │  5. Ждёт завершения          │    │
│                     │  6. Ставит - [x]             │    │
│                     │  7. Следующий - [ ]          │    │
│                     │  8. Все сделано? → Runs/log  │    │
│                     └──────────┬───────────────────┘    │
│                                │                        │
│              ┌─────────────────┼─────────────────┐      │
│              │                 │                 │      │
│        ┌─────▼──────┐   ┌──────▼──────┐   ┌─────▼─────┐ │
│        │ Сессия #1  │   │ Сессия #2   │   │ Сессия #3 │ │
│        │ Claude Code│   │ Codex       │   │ OpenCode  │ │
│        │            │   │             │   │           │ │
│        │ worktree/  │   │ worktree/   │   │ worktree/ │ │
│        │ feat-api   │   │ feat-ui     │   │ feat-test │ │
│        └────────────┘   └─────────────┘   └───────────┘ │
│              │                │                 │       │
│              └────────► git merge ◄─────────────┘       │
│                           │                             │
│                     ┌─────▼─────┐                       │
│                     │   main    │                       │
│                     └───────────┘                       │
└─────────────────────────────────────────────────────────┘
```

### 7.2. Auto Run: исполнение playbook-ов

**Процесс:**
1. Выбираете папку с playbook-ами
2. Auto Run берёт первый документ, читает чеклист сверху вниз
3. Каждая задача `- [ ]` отправляется агенту в свежей сессии
4. Агент выполняет задачу, Auto Run ставит `- [x]`
5. Документы без невыполненных задач пропускаются
6. Прогресс: "Document 2 of 5, Task 3 of 8"

**Изоляция сессий.** Каждая задача выполняется в чистой сессии — нет протекания контекста. Без изоляции к 10-й задаче контекстное окно забито артефактами первых девяти.

**Loop Mode** — Auto Run может зацикливать playbook-ы. Каждый прогон сохраняется как артефакт в `Runs/` с таймстампом.

### 7.3. Параллельная работа через worktrees

Maestro создаёт отдельного суб-агента для каждого worktree. У каждого своя рабочая директория, история и состояние — три агента пишут три фичи параллельно без конфликтов.

### 7.4. Group Chat: координация между агентами

**Как работает:**
1. Модератор (отдельный агент) управляет дискуссией
2. Участники подключаются через @mention: `@backend-agent`, `@frontend-agent`
3. Модератор получает вопрос, делегирует нужным агентам
4. Агенты отвечают в контексте своих проектов
5. Модератор синтезирует ответы и возвращает результат

Пример: "Агент backend, какой формат ответа у endpoint /api/users? Агент frontend, совпадает ли он с тем, что ты ожидаешь?" → модератор получает оба ответа, находит расхождение, просит агентов согласовать контракт.

### 7.5. Wizard: генерация playbook-а из диалога

Команда `/wizard` генерирует playbook из диалога: описываете задачу в свободной форме, AI задаёт уточняющие вопросы, при достаточной уверенности генерирует готовый playbook с чеклистом.

Документация Maestro: https://docs.runmaestro.ai/autorun-playbooks

## 8. Мониторинг и конфликты

### 8.1. Мониторинг агентов

**Метрики для отслеживания:**

| Метрика | Что показывает |
|---------|---------------|
| Время на задачу (median, p95) | Сколько в среднем агент тратит на атомарную задачу |
| Количество итераций до успеха | Сколько раз агент прогонял цикл Do→Check→Fix |
| Расход токенов | Сколько стоила задача |
| Процент успешных завершений | Сколько задач доведено до PR без ручного вмешательства |

### 8.2. Конфликты при слиянии результатов

Два агента изменили один файл. Как разрешить:

1. **Ручное ревью** — человек объединяет изменения. Для критичного кода.
2. **Агент-арбитр** — третий агент читает оба варианта и предлагает решение. Для простых конфликтов.
3. **Повторный запуск** — откатываем одного агента и перезапускаем с учётом изменений другого.

### 8.3. Lessons learned: эволюция знаний

1. **Состояние работы** (git-based) — коммиты, PR, issue tracking.
2. **Контекст проекта** (артефакты) — архитектура, стек, принятые решения. Хранится в `docs/constitution.md`.
3. **Знания по самоулучшению** (lessons → skills) — агент решил сложный баг → записал lesson → lesson попадает в constitution → следующий агент не совершит ту же ошибку.

## 9. Честно про сложности

**Первое время медленнее.** Первые недели уйдут на настройку, отладку, разрешение конфликтов.

**Инфраструктура и стоимость.** Бюджет агентов, credential management, мониторинг — требует настройки. Оплата за токен по API слишком затратна — берите подписки и бесплатные сервисы, крутите до лимитов.

**Когда оркестратор уместен:**
- Проект с хорошим тестовым покрытием и CI — агенты могут автоматически проверять свою работу
- Задача декомпозируется на 5+ независимых подзадач с чёткими критериями приёмки
- Повторяющиеся задачи одного типа (миграция 20 сервисов, обновление API в 15 клиентах)
- Проект с устоявшейся архитектурой и конвенциями, описанными в constitution
- Команда уже освоила работу с одним агентом и упирается в пропускную способность

**Трудные сценарии для оркестратора:**
- Низкая толерантность к рискам и багам (жизненно важная инфраструктура, медтехника)
- Исследовательская задача со множеством неизвестных — сначала ресерч и спека, потом оркестратор
- Legacy код без тестов и документации — слишком много неявного контекста и тех. долга
---

[← 5. Ролевая модель агентов](03-roles-and-patterns.md) | [Оглавление](../../../README.md) | [Git worktree для изоляции агентов →](../practice/01-git-worktree.md)
