# Задача 10: Модуль 7 — Параллельные агенты и оркестрация (теория)

## Цель

Написать текст теоретической части Модуля 7. Ключевой сдвиг: разработчик перестаёт быть кодером и становится проектировщиком решений, менеджером оркестратора и контролёром качества. Переход от одного агента к координации нескольких.

## Что написать

Текст на ~2000 слов.

1. **Сдвиг роли: от кодера к архитектору оркестра** (3-4 абзаца):
   - Главная мысль модуля: на уровне 5 суть работы разработчика меняется. Кодинг не исчезает, но перестаёт быть основной деятельностью.
   - Было: разработчик = пишет код руками (с помощью агента или без). Стало: разработчик = проектирует решения + настраивает оркестратор + контролирует качество.
   - Три новые компетенции:
     - **Проектирование**: писать спецификации, которые агенты могут автономно исполнить. Чем точнее спека — тем лучше результат.
     - **Менеджмент оркестратора**: настраивать роли агентов, выбирать модели под задачи (умная планирует, дешёвая кодит), тюнить стратегии (когда перезапускать, когда менять агента).
     - **Контроль качества**: приёмка результатов, code review PR-ов от агентов, мониторинг метрик (время, итерации, расход токенов).
   - Аналогия из Enji Fleet: менеджер проекта ставит задачу → флит агентов автономно декомпозирует, кодит, тестит, оформляет PR → разработчик ревьюит и мерджит. Разработчик = мейнтейнер флита, решатель блокеров, оптимизатор скорости.
   - Кодинг остаётся там, где агенты не справляются: сложная бизнес-логика, интеграции без документации, архитектурные решения, отладка нетривиальных багов.
   - Цитата из Enji Fleet: "Разрабы становятся мейнтейнерами флита, решателями блокеров, оптимизаторами скорости флита и его ресурсов."

2. **Зачем параллельность** (2 абзаца):
   - Один агент = одна задача. Пропускная способность упирается в скорость агента.
   - Несколько агентов = несколько задач одновременно. Фронтенд и бэкенд параллельно. Код и тесты параллельно.
   - Когда это оправдано, а когда нет (маленькая задача → один агент, фича из 5 подзадач → параллельность).

3. **Изоляция контекстов** (2 абзаца):
   - Каждый агент — своя сессия, свой контекст, свой scope работы
   - Зачем изоляция: агенты не должны мешать друг другу, перезаписывать файлы
   - Git worktrees: одна копия репозитория → несколько рабочих директорий → каждый агент работает в своей
   - Как создать worktree, как переключаться, как слить результат

4. **Ralph Loop и fail-until-done** (2-3 абзаца):
   - Цикл агентной работы: plan → implement → test → review → iterate
   - Каждый шаг может быть отдельным агентом или отдельной сессией
   - Пример полного цикла для задачи "добавить endpoint"
   - **Fail-until-done** (из Enji Fleet): агент маслает пока не сделает. Цикл Do → Check (Tests/Lint) → Fix. Если тест упал — агент не останавливается, а исправляет. Критерий остановки — все проверки пройдены.
   - Ссылки: https://ghuntley.com/ralph/, https://dev.to/alexandergekov/2026-the-year-of-the-ralph-loop-agent-1gkj

5. **Ролевая модель агентов** (2-3 абзаца):
   - Из опыта Enji Fleet: не один универсальный агент, а специализированные роли:
     - **Архитектор**: анализ требований, проектирование системы (умная модель: Opus/GPT-5)
     - **Планировщик**: декомпозиция на атомарные задачи с зависимостями (средняя модель)
     - **Разработчик**: реализация конкретной задачи, self-check (lint/tests) (дешёвая/быстрая модель)
     - **QA**: тестирование результата, формирование баг-репорта (средняя модель)
   - Принцип: разные модели для разных ролей. Не тратить Opus на boilerplate, не ставить Haiku на архитектуру.
   - Agents-hot-swap: если агент зациклился или упёрся в лимит — оркестратор заменяет его другим агентом (Claude → Codex → Gemini). Задачи атомарные, поэтому замена безболезненна.
   - Все роли общаются через координатора, не напрямую.

6. **Паттерны оркестрации** (3-4 абзаца):
   - **Генератор + Ревьюер**: один агент пишет код, другой проверяет. Простейший паттерн. Результат ревьюера → обратно генератору.
   - **Декомпозиция**: разбить фичу на подзадачи, раздать разным агентам. Пример: API + фронтенд + тесты = 3 агента.
   - **Иерархия** (RPI→R из Enji Fleet): координатор управляет цепочкой Research → Plan → Implement → Review. Координатор не пишет код, а формирует задачи с чёткими критериями приёмки. Если валидатор не принял — задача возвращается. Иерархия: Roadmap → Phase → Task → Atomic Task. Агент не пишет код, пока не спустился до Atomic.
   - Для каждого паттерна: когда использовать, плюсы, минусы.

7. **Runbook / "Библия" оркестратора** (2 абзаца):
   - Что это: формализованный план работы для нескольких агентов + верхнеуровневый ценностный документ
   - Библия (из Enji Fleet): кто ты, что ты, для чего ты, кому и как помогаешь. От библии выкристаллизовывается вся спека для флита. Разные проекты = разные библии.
   - Runbook: задача → подзадачи → кому какая → порядок → критерии приёмки → как сливать
   - Пример runbook для реальной фичи (5-10 строк)

8. **Мониторинг, конфликты и lessons learned** (2-3 абзаца):
   - Мониторинг: heartbeat от агентов, логи действий, метрики (время на задачу, итерации, расход токенов). Если агент долго не отвечает — перезапуск.
   - Конфликты: два агента изменили один файл. Как разрешить: merge, ручное ревью, повторный запуск одного из агентов.
   - Lessons learned: агент после сложной задачи фиксирует что пошло не так. Эти знания доступны другим агентам и улучшают работу оркестратора со временем. Типы памяти (из Enji Fleet): состояние работы (git-based), контекст проекта (артефакты), знания по самоулучшению (lessons → skills).

9. **Дополнительные возможности для параллельной разработки** (3-4 абзаца):
   - **Claude Code в облаке**: headless-режим (`claude -p`), работа на удалённых серверах (EC2, VPS, Docker). GitHub Actions (`anthropics/claude-code-action@v1`) и GitLab CI/CD. Зачем: масштабирование за пределы одной машины, автоматизация в CI.
   - **Долговременные auth-токены**: `ANTHROPIC_API_KEY` для API-биллинга, `claude setup-token` для генерации 1-годового OAuth-токена (для подписчиков Max). `CLAUDE_CODE_OAUTH_TOKEN` для headless-автоматизации. Альтернативы: Amazon Bedrock (`CLAUDE_CODE_USE_BEDROCK=1`), Google Vertex AI, Azure Foundry.
   - **Claude Agent SDK**: официальный SDK (Python `claude-agent-sdk`, TypeScript `@anthropic-ai/claude-agent-sdk`) для построения кастомных оркестраторов. Программные субагенты, хуки, MCP-серверы, управление сессиями. Пример: кастомный бот, который берёт задачу из Jira → декомпозирует → запускает агентов → собирает результат.
   - **Agent Teams** (experimental): `CLAUDE_CODE_EXPERIMENTAL_AGENT_TEAMS=1`. Множественные Claude Code сессии с shared task list, inter-agent messaging, plan approval mode. Пример Anthropic: 16 агентов, ~2000 сессий, 100K строк Rust-компилятора C.
   - **OpenClaw** (https://github.com/openclaw/openclaw, 188K stars): open-source платформа автономных агентов Питера Штайнбергера. Multi-agent routing с разными моделями на разные задачи, интеграция с Claude Code через MCP, экосистема оркестраторов (Claworc для управления инстансами, Antfarm для team-of-agents). Не для кода напрямую, а для координации: Slack, Jira, email, браузер + code agents.

## Тон и стиль

- Это самый продвинутый модуль — но ученик уже прошёл 6 модулей, можно использовать терминологию
- Ключевой тон: "твоя работа меняется, и это нормально". Не пугать, а показать, что новая роль (проектировщик + менеджер + контролёр) — это эволюция, а не потеря профессии
- Каждый паттерн — с примером. Не абстрактные диаграммы, а "вот что ты делаешь".
- Примеры из Enji Fleet: конкретные сценарии из Mad Devs (HR-боты, фичи Enji, контент для сайтов)
- Честно про сложности: параллельность добавляет overhead, не всегда оправдана. Первое время агенты делают медленнее человека — ценность в масштабе и 24/7

## Формат результата

MD-файл `course/module-7-orchestration/theory.md`

## Критерии приёмки

- Сдвиг роли разработчика явно описан: от кодера к проектировщику + менеджеру оркестратора + контролёру качества
- Ролевая модель агентов: архитектор, планировщик, разработчик, QA — с привязкой к моделям
- Fail-until-done и agents-hot-swap объяснены
- Git worktrees объяснены с командами
- Ralph Loop описан с конкретным примером
- 3 паттерна оркестрации: генератор+ревьюер, декомпозиция, иерархия (RPI→R)
- Пример runbook + концепция "Библии" оркестратора
- Lessons learned и типы памяти оркестратора
- Честно про overhead и когда НЕ нужна параллельность
- Обзор cloud-возможностей: headless-режим, auth-токены, Agent SDK, Agent Teams
- Упоминание OpenClaw с позиционированием (что это, зачем, как интегрируется)

## Зависимости

- Задача 03 (какой агент рекомендуем — нужно для примеров)

## Входные данные

- `sources/Enji Fleet.md` — ролевая модель (архитектор→планировщик→разработчик→QA), RPI→R цикл, fail-until-done, agents-hot-swap, "Библия" оркестратора, типы памяти, сдвиг роли разработчика к мейнтейнеру флита
- `sources/Контент-план по курсу ИИ.pdf` — Модуль 3: Оркестрация, Ralph Loop, Иерархические системы
- `sources/Портрет ИИ зрелости.md` — уровни 4-5, раздел "Параллельность и управление"
- `sources/старый документ: уровни AI usage maturity.pdf` — уровни 4-5
- `sources/enji-fleet-analysis.md` — практики 4-12 (Docker image, CLI registry, профили, MCP, credentials, hot-swap, worktree, промпт, Memory Service)

## Примеры из Enji Fleet (обязательно использовать)

Репозиторий: `/home/kb/Documents/workspace/mad_devs/enji-fleet`

**Это ключевой модуль для примеров из Fleet.** Fleet -- работающая реализация всего, что описано в теории.

### Для секции "Ролевая модель агентов"
Реальные профили агентов (`backend/services/agent/agent-profiles.yaml`):
- `claude-developer`: roles [developer, reviewer, tester], model sonnet, max_turns 100, priority normal
- `claude-architect`: roles [planner, reviewer, evaluator], model sonnet, max_turns 50, priority high
- `codex-developer`: roles [developer, tester], model codex-mini, priority low

Показать: разные модели для разных ролей. Architect с высоким приоритетом, Codex для дешёвых задач.

### Для секции "Agents-hot-swap"
Из `docs/ideas/2026-01-27-smart-agent-pool.md`:
- YAML-конфигурация пула с Claude/Codex/Gemini/Ollama/Amp/Kilo
- Team pooling: квоты Alice + Bob + Carol в одном пуле
- Ночная смена: `availability_window: "00:00-08:00"` -- используем токен Боба ночью
- Три механизма: Timeout Swap, Error Swap (429/5xx), Critic Swap (N провалов → эскалация на Opus)
- `daily_budget: 10` -- трекинг бюджета по аккаунтам

### Для секции "Изоляция контекстов"
Из `AGENTS.md` -- worktree обязателен:
```bash
git worktree add ../enji-fleet-<plan-name> -b feat/<plan-name>
cd ../enji-fleet-<plan-name>
git worktree remove ../enji-fleet-<plan-name>
```
Одна ветка = один план. Параллельные агенты не мешают друг другу.

### Для секции "Паттерны оркестрации"
CLI registry (`backend/cmd/fleet-sdk/internal/clibuilder/config.go`) -- Go-код абстракции над 4 AI CLI. Показывает, как унифицировать интерфейс для hot-swap: у Claude `--append-system-prompt`, у Codex `--full-auto`, у Gemini `--yolo` -- но Fleet SDK знает как с каждым работать.

Docker image (`fleet-agent-image/Dockerfile`) -- один образ с 4 AI CLI (Claude, Codex, Gemini, OpenCode) + Fleet SDK. Entrypoint: `fleet-sdk run`.

### Для секции "Мониторинг и lessons learned"
- Trace-файлы (`docs/traces/`) -- 25+ артефактов с секциями "Для конституции" и "Технические решения"
- reflect-mode (`.agent/workflows/reflect-mode.md`) -- отдельный агент-аудитор, который консолидирует traces в constitution
- Memory Service с ChromaDB и 3 embedding-провайдерами (OpenAI, Ollama, Gemini)
- MCP tools: report_progress, report_error для heartbeat от агентов

### Для секции "Credential Management"
`backend/cmd/fleet-sdk/internal/credentials/manager.go` -- Go-код для инъекции credentials:
- Session tokens из ENV → auth-файлы для каждого CLI
- JSON-валидация, chmod 0600, mkdir -p
- Разные пути для разных CLI: `.claude/.credentials.json`, `.codex/auth.json`, `.local/share/opencode/auth.json`
