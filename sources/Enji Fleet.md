# Enji Fleet

Внутренний слоган: *девелоперский каннибализм*  
Внешний слоган: *вашей компании больше не нужен айти отдел*

## Основной стейтмент

*Любые* команды и *любые* компании с работающим 24 на 7 оркестратором флита кодинг агентов и выдающий хоть какой-то принимаемый людьми результат к концу 2026 года закроют больше целей чем те, у которых оркестратора нет.

## Какие проблемы хотим решать?

* Код пишется все еще людьми, что тормозит разработку. Даже вместе с ллмками, выдавая больше кода, мы все равно упираемся в человека.  
* Пользователи все еще ходят к разработчикам за выполнением задач, хотя обученные агенты могут это делать вместо разработчиков.  
* Агенты уже сейчас в состоянии писать код лучше человека, но компании и команды по старой привычке все равно поручают человеку задачи.  
* Отсутствие автоматических платформ с обученными агентами, которые делают то, что нужно делать, оставляет команды и компании со старыми привычками, обнажая их перед вызовами рынка (компании и команды где по задачам людей автономно работают сотни и тысячи агентов съедят тех, кто работает в той же сфере но руками).  
* Рынок, уже получивший на руки кодинг агентов с умными моделями, начинает создавать аппки сам, то есть программист перестает быть создателем приложений. Приложения уже создаются самими пользователями и им не нужен больше опыт в разработке, им в этом помогает сам агент.

## Какую цель преследуем и для чего?

* Создаем оркестратора, цель которого работать по задачам компании, отделов или проектов 24 на 7\. Оркестратор ВСЕГДА выдает нужный результат по задаче, просто он может это делать либо быстро, либо очень долго.  
* Формируем привычки у компаний, отделов и команд ВСЕГДА кормить задачи в оркестратор, чтобы он варил все что только может сварить. Сначала он варит долго, криво, не оптимально. Потом с эволюцией внутренних инструкций и с появлением более умных моделей оркестратор просто внезапно начинает   
* Есть готовые спеки для агентов которые могут это делать, но чтобы подпереть их до 100% валидности можно юзать линтеры.  
* выдавать результаты лучше, вовлекая в себя еще больше пользователей.  
* Приучаем команды разработки, которые пишут большие проекты, кормить в оркестратор какой-то спектр задач, которые он в состоянии выполнять.  
* Эволюционно менеджеры начинают кормить задачи в проектный оркестратор, а не разработчикам или оркестратор может подхватывать сам первым баги из Sentry.  
* Приучаем сотрудников компании и отделов давать оркестратору задачи на корпоративные аппки точно так же, как они давали их раньше в ИТ-отдел или аутсорсерам. Эволюционно оркестратор будет в состоянии обслужить 90% запросов компании или отдела.

## Критерии успеха

* Эйчар отдел МД перестал ходить в СТО за добычей фичей для своих ботов, они ставят задачи в \`Enji Fleet\` получают ожидаемый результат, боты появляются на продакшене, делают то что от них хотят.   
* Алла из МД использует \`Enji Fleet\` для своих задач по автоматизации своей рутины не связанной с продуктом \`enji\`  
* Отдел Маркетинга прекращает ставить задачи программистам на улучшение \`marketing radiator\`, а ставит эти задачи в \`Enji Fleet\`.  
* Команда разработчиков и лидеров Энжи использует \`Enji Fleet\` для определенного спектра задач и эти задачи доходят до продакшена через приемку пиаров от флита людьми. Разгружается бэклог. Фичи уходят в прод в 10 раз быстрее, чем сейчас.  
* Команда разработчиков сайтов \`enji.ai\` и \`maddevs.io\` использует \`Enji Fleet\` для всех рутинных задач и начинает вовлекать стейкхолдеров этих проектов ставить задачи определенного толка в \`Enji Fleet\`.  
* Появился первый коммерческий клиент \`Enji Fleet\`, например фонд Accelerate Prosperity, который использует оркестратор для создания своих небольших корпоративных приложений для внутреннего и для внешнего пользования не привлекая при этом \*ни одного\* разработчика за деньги.

## Что нам нужно от нашего оркестратора?

* **RPI-\>R** подход: Research \-\> Plan \-\> Implement \-\> Review cycle  
  * детальное планирование, **цепочка мелких тасков** от плана, подпорка тестами, линтеры, секурити  
  * у каждой задачи формируется четкий критерий приемки, чтобы можно было понять когда останавливаться агентам и когда консолидатору быть уверенным в том, что агенты закончили работу   
    * то есть мы не просто выполнили все таски, мы запустили проверятора по выполненным таскам и даем ему опцию вернуть задачу обратно на доработку  
*  **fail-until-done** подход: **маслаем пока не сделаем**  
  * A robust implementation of the "*Ralph Wiggum*" technique: continuously running an AI agent against a prompt file until a completion condition is met.  
    * [https://ghuntley.com/ralph/](https://ghuntley.com/ralph/)   
    * [https://dev.to/alexandergekov/2026-the-year-of-the-ralph-loop-agent-1gkj](https://dev.to/alexandergekov/2026-the-year-of-the-ralph-loop-agent-1gkj)  
    * [https://x.com/mattpocockuk/status/2007924876548637089](https://x.com/mattpocockuk/status/2007924876548637089)  
    * [https://x.com/mattpocockuk/status/2008200878633931247](https://x.com/mattpocockuk/status/2008200878633931247)	  
  * можно использовать комбинированный подход между \`sugar\`, \`get-shit-done\` и \`ralph-orchestrator\`  
    * Жестко заданный пайплайн: 1\. \`Research\` (читать код, гуглить) \-\> 2\. \`Plan\` (создать документ с планом) \-\> 3\. \`Implementation\` (писать код) \-\> 4\. \`Review\` (проверять).  
    * Строгая иерархия *Roadmap \-\> Phase \-\> Task \-\> Atomic Task*. Отсюда используем подход *atomic task*: агент не имеет права писать код, пока не спустится на уровень Atomic.  
    * Цикл *Do \-\> Check (Tests/Lint) \-\> Fix*. Если тест упал или валидатор не принял работу, план следующего шага — "исправить ошибку X".  
* **agents-hot-swap** подход: **меняем кодинг агентов на лету**, чтобы не простаивать упершись в лимиты или в баги агентов (агенты могут просто вставать колом по разным причинам)  
  * суем в оркестратор максимально много кодинг агентов и учим оркестратор запускать и мониторить каждый (большая часть их может работать хедлесс или выдавать логи в консоль чтобы по ним ориентироваться)   
  * \`claude\`, \`codex\`, \`cursor-agent\`, \`opencode\`, \`gemini\`, \`amp\`, \`kiro\`  
  * урлы к фришным моделям через апишку и ключ к \`openrouter\` (но в этом случае модели надо спекать в агенство и учить тулам, следовательно оркестратору нужно знать какие задачи поручать в этим модели)  
  * замененный агент либо начинает таску заново (окей, потому что таски должны быть мелкие), либо продолжает таску с момента ее завершения (в этом случае агент должен уметь подхватывать сессию другого агента)  
* **auditors-checks** подход: раз в сутки или раз в неделю в каждом проекте создается задача на аудиторство тестов, кода, безопасности умными агентами с соответствующими ролями, чтобы они по итогу насыпали в пайплайн необходимых задач на *PRI-\>R*  
* **enji-mcp** тул для получения контекста о доменной области или приоритетам.  
  * Оркестратор в процессе рисерча и планирования может обратиться к \`enji\` по \`mcp\` для добычи контекста по проекту, уточнениям задач, получению чего либо еще. Мотивы запросов от оркестратора в Энжи будет управлять приоритетами \`enji agent\` разработки.  
* **два режима работы**:   
  * **для команды разработчиков** проекта  
    * задачи в \`enji fleet\` отправляются менеджерами проекта или самими разрабами проекта  
    * флит научен автономно допинывать какой-то тип задач, об этом знает сам флит и сама команда и грузит флит задачами, которые он в состоянии переварить  
    * результат: оформленный пул реквест на ревью и мерж человеку  
  * **для сотрудников компании** или отдела  
    * задачи в \`enji fleet\` отправляются сотрудниками компании или отдела, то есть теми кто не принимает участия в разработке проектов напрямую  
    * флит понимает как нужно проектировать задачи для компании-отдела, понимает тип задач который может приходить (боты, лендосы, апишки, сайты, прилы), флит понимает в каком виде и по какой дизайн системе надо оформлять продукты, флит обладает доступами до продовой инфры куда он может деплоить свои результаты (это может быть какой-то защищенный броузерный энвайромент, а какие-то аппки из флита могут быть упакованы в \`wasm\`)  
    * результат: задеплоенная аппка доступная для работы сотрудником компании

## Похожие решения

В целом, уже есть нечто похожее на рынке. Репозиторий с исследованием: [https://github.com/maddevsio/orchestrator](https://github.com/maddevsio/orchestrator). Сравнительная таблица есть [здесь](https://github.com/maddevsio/orchestrator/blob/main/COMPREHENSIVE_ANALYSIS.md).

Наиболее интересные решения оттуда:

* [https://github.com/AndyMik90/Auto-Claude](https://github.com/AndyMik90/Auto-Claude) \- здесь есть многое из того, что описано в этом документе. Проблемы:  
  * Сильно завязано на UI.  
  * Заточено под рабочее место для человека. Мы хотим замкнутый цикл, где человек получает конечный результат.  
  * Ограниченное количество агентов для параллельной работы. Все-таки рассчитано на человека и что он может разобраться в том, что происходит.  
* [https://github.com/smtg-ai/claude-squad](https://github.com/smtg-ai/claude-squad) \- не дотягивает до предыдущего, но умеет работать с разными агентами в режиме “автосогласия” на изменения.  
* [https://github.com/steveyegge/gastown](https://github.com/steveyegge/gastown) \- монументальное но сложное решение, к которому мир еще не готов. Внутри много готовых концепций для масштабирования, однако не факт, что приспособлено для облачного использования. В дополнение \- нет переключения между CLI-ками. Статью можно почитать [здесь](https://steve-yegge.medium.com/welcome-to-gas-town-4f25ee16dd04).  
* [https://github.com/context-machine-lab/sleepless-agent](https://github.com/context-machine-lab/sleepless-agent) \- как будто то, что мы хотим. Но для себя и на своих условиях. Сильно завязан на Клод.

## Концептуальная опора

Чтобы было проще понять как такая система устроена, вот несколько ключевых концептуальных тезисов:

* **Человек нужен только для приемки готовой работы.** UI опционален и может быть расположен на стороне, для **надзора** и **вмешательства**, но не для контроля. Человеку должно быть понятно “*что происходит*”, соответственно агенты должны оставлять понятные артефакты своей работы или логи действий.  
  * Основная цель UI \- “успокоить” пользователя, дать инструмент “причастности” к происходящему, минимизировать фрустрацию. Пользователю надо дать видимость за работой системы логи стримов коммуникации, переключения, метрики, актуальный статус работы, общий прогресс реализации. Вмешательство пользователя будет только тормозить весь процесс.  
  * UI может (но не обязательно) быть похож на KANBAN доску для того, чтобы людей было легко и понятно онбордить в процесс. *В перспективе* (не сейчас) может быть здесь уместно использовать опыт из видеоигр (стратегий, где надо менеджить целую армию) или симуляторов (градостроительных, например).  
  * Важно мочь поставить задачу откуда угодно. Будь то команда, отдел, директор или кто-либо еще, кто может ставить задачу. Работа должна делаться в облаке. Важно понимать, что проект может использоваться локально, но предназначен он в основном для облачного использования. А это значит, что нам нужно API для программного взаимодействия с ним или механизм “как достать задачу” для текущего кластера и “общей очереди” (где-то, неизвестно где \- аналог пула транзакций в БЧ).  
  * Должны быть оповещения о том, что “работа сделана” и человеку пора смотреть “*что получилось*”. Если говорить про асинхронную работу, то многие это делают через мессенджер (Slack, Telegram, etc.) или, в теории, через почту с подробным отчетом, где есть ссылки на всё необходимое для запуска результатов, проверки, изучения деталей.  
  * Метрики и показатели для ориентира, которые будут интересовать пользователя:  
    * Доступный объем токенов по каждой подключенной учетной записи (т.е. текущий доступный бюджет, его доступный остаток).  
    * Количество задач, оставшееся до окончания работы.  
    * Среднее время, которое уходит на решение задачи.  
    * Примерное время, которое осталось до завершения пользовательской задачи.  
    * Прогресс по текущей пользовательской задаче (эпик).  
    * Готовые задачи к приемке пользователем в данный момент.  
    * Задачи в работе на сейчас.  
    * Время, ушедшее на самую долгую задачу за сегодня.  
    * Задача с самым большим количеством повторных попыток за последние 2 часа.  
    * Сколько агентов работает на данный момент (и на каких моделях).  
    * Статистика времени и траты токенов каждой ролью агента по текущей пользовательской задаче.  
    * Текущий хартбит системы: события, действия в виде логов из хуков от агентов. Пример: агент X начал готовить план, закончил готовить план, агент Y начал писать код, запустил линтер, запустил тесты, смержил изменения и т.д.  
* **Агенты \- как “муравьи”** (небольшие, адаптированные). Они работают качественнее, когда обязательства и ответственность грамотно распределены. Гигантов-мутантов нет. Топология взаимодействия может конфигурироваться, но на первом этапе достаточно одной работоспособной (которая будет планомерно улучшаться).  
  * Многие прибегают к схеме супервизора / координатора / роутера (как [здесь](https://github.com/awslabs/agent-squad?tab=readme-ov-file#-introducing-supervisoragent-agents-coordination), [здесь](https://github.com/awslabs/cli-agent-orchestrator) или [здесь](https://github.com/steveyegge/gastown/?tab=readme-ov-file#basic-workflow)), который берет задачу и потом назначает её соответствующим субагентам (или спавнит их) \- архитектору, планировщику, исполнителям, проверке качества и т.д. Это можно организовать расписав роли и требуемые артефакты для каждой, чтобы продолжить работу на месте или передать работу дальше.  
  * Важно также понимать, что у каждого агента свое предназначение, своя ограниченная роль, своя модель (для рационального использования токенов, прим. Claude Haiku, Opus, Sonnet для разной работы), и, вероятно, свои инструменты. Мы не хотим излишне тонуть в разработке инструментов. Во многих случаях лучше инструктировать агента писать код для использования внешнего ПО, чем подключать 100500 MCP и т.д. \- такой подход экономит контекстное окно.  
  * Есть вопросы к изоляции работы, если мы хотим достигнуть параллелизации. Многие из похожих проектов предполагают запуск на одной машине, потому что инструментов требуется много и проще иметь один сетап где отличия только в дисковом пространстве. Т.е. один сетап тулов, но много папок с рабочими копиями, где делается несколько не конфликтующих фич одновременно. Только немногие используют докер. **На сейчас рассматриваем только Git Worktree**, в дальнейшем можно рассмотреть докер при возникновении проблем с портами, отключениями сервисов и т.д.  
  * Если мы будем спавнить много агентов, то надо как-то убеждаться, что они продолжают работу (не зациклились, не умерли). Есть 3 варианта как это делать: А) промежуточная отчетность от агентов для супервизора, Б) хелсчек от супервизора за агентами, или В) стриминг событий с агентов, определение в расхождении ожиданий (предлагает Палыч). Если какой-то агент долго не отвечает (нет отчета, хелсчек отрицательный, стрим прервался), то отключаем его и перезапускаем работу.  
* **Несколько видов долгосрочной памяти:**  
  * **Состояние работы.** Решается через git-based трекинг, графовый трекинг (взаимозависимости). Если мы говорим про графы, то становятся доступны соответствующие алгоритмы: дерево зависимостей и параллелизация, критический путь, взвешивание. Из-за них [Beads](https://github.com/steveyegge/beads) реализовано на графах и имеет [множество community-backed UI-ек](https://github.com/steveyegge/beads/blob/main/docs/COMMUNITY_TOOLS.md).  
  * **Контекст о текущем проекте**, чтобы не сканить код заново. Агентам надо онбордиться, если они будут часто запускаться на отдельных задачах. Сюда также может подойти лог решений. Могут быть прочие **артефакты**, которые не фигурируют в коде, но как-то полезны для определения текущего состояния (например, промежуточные отчеты или заметки, которые облегчают повторный онбординг в задачу / проект и позволяют работать не с нуля). В теории решается через RAG или хранение в репозитории.  
  * **Контекст по самоулучшению**. Это переносимая память между проектами и задачами, которая ориентирована на оптимизацию собственной роли, подходов, недопущения повторных ошибок (которые привели к зацикливанию, простоям, переделкам). По идее пополняется редко и не должен занимать больших объемов.  
  * **Нюансы:**  
    * Память будет бесконечно накапливаться. Соответственно надо продумать механизм очистки / обобщения опыта, определения вещей, которые становятся бесполезны (чтобы их выкидывать).  
    * Агент загружает на старте самоулучшения и контекст о проекте. Состояние работы может запрашивать по мере необходимости.

## Ролевая модель

***Дисклеймер:** Этот раздел в целом демонстрационный, чтобы показать как можно. Это может быть и правильно, но не обязательно эффективно. В основе лежит SDLC и артефакты от него. Презентацию вы можете почитать [здесь](https://docs.google.com/presentation/d/1wSp32I4Mbgh59tHIew_Q1MlpAjTyn57iUupGfZ7d5vM/edit). Могут быть уместны и эффективны более простые модели цикла производства. Помните: чем больше ролей, тем больше придется производить обмена контекстом. Большое количество ролей \- это дорого. В некоторых случаях лучше сохранять автономию до тех пор, пока бюджет не бесконечен.*

| flowchart TD     User \--\> O0\[Получить задачу\]          subgraph Orchestrator         O0 \--\> O1{Архитектура существует?}         O1 \-- Нет \--\> O2\[Создать задачу для Architect\]         O1 \-- Да \--\> O3{План задач существует?}         O2 \--\> O4\[Получить артефакт архитектуры\]         O4 \--\> O3         O3 \-- Нет \--\> O5\[Создать задачу для Planner\]         O3 \-- Да \--\> O6\[Начать выполнение плана задач\]         O5 \--\> O7\[Получить план задач\]         O7 \--\> O6                  O6 \--\> O8{Все задачи завершены?}         O8 \-- Нет \--\> O9\[Выбрать следующую задачу\]         O9 \--\> O10\[Создать задачу для Developer\]         O10 \--\> O11\[Получить отчет о завершении задачи\]         O11 \--\> O12\[Отметить задачу как выполненную\]         O12 \--\> O8                  O8 \-- Да \--\> O13\[Создать задачу для DevOps\]         O13 \--\> O14\[Получить ссылку на развертывание\]         O14 \--\> O15\[Создать задачу для QA\]         O15 \--\> O16\[Получить отчет от QA\]         O16 \--\> O17{QA пройдена?}         O17 \-- Нет \--\> O18\[Создать задачу для Planner на основе баг\-репорта\]         O18 \--\> O19\[Получить обновленный план с задачами на баги\]         O19 \--\> O8         O17 \-- Да \--\> O20\[Уведомить User о готовности\]     end     subgraph Architect         A1\[Проанализировать требования\] \--\> A2\[Спроектировать архитектуру\]         A2 \--\> A3\[Вернуть артефакт архитектуры\]     end     subgraph Planner         P1\[Проанализировать архитектуру\] \--\> P2\[Декомпозировать на задачи\]         P2 \--\> P3\[Определить зависимости\]         P3 \--\> P4\[Вернуть план задач\]                  P5\[Получить задачу на создание плана багов\] \--\> P6\[Проанализировать баг\-репорт QA\]         P6 \--\> P7\[Создать задачи на исправление багов\]         P7 \--\> P8\[Добавить задачи в существующий план\]         P8 \--\> P9\[Вернуть обновленный план\]     end     subgraph Developer         D1\[Получить задачу\] \--\> D2\[Разработать решение\]         D2 \--\> D3\[Написать код\]         D3 \--\> D4\[Самопроверка кода\]                  subgraph Self-check             SC1\[Запустить линтер и форматирование\]             SC2\[Написать автотесты\]             SC3\[Проверить покрытие кода тестами\]             SC4\[Проверить соответствие конвенциям\]             SC5\[Проверить архитектурные принципы\]                          SC1 \--\> SC2 \--\> SC3 \--\> SC4 \--\> SC5 \--\> SC6{Все проверки пройдены?}         end                  D4 \--\> Self-check         SC6 \-- Да \--\> D5\[Смерджить изменения\]         SC6 \-- Нет \--\> D2         D5 \--\> D6\[Вернуть отчет о завершении\]     end     subgraph DevOps         DV1\[Получить задачу\] \--\> DV2\[Собрать проект\]         DV2 \--\> DV3\[Развернуть на тестовом окружении\]         DV3 \--\> DV4\[Вернуть ссылку на развернутый проект\]     end     subgraph QA         Q1\[Получить задачу\] \--\> Q2\[Протестировать систему\]         Q2 \--\> Q3\[Выявить баги и несоответствия\]         Q3 \--\> Q4\[Сформировать баг\-репорт\]         Q4 \--\> Q5\[Вернуть отчет\]     end     O2 \--\> A1     A3 \--\> O4     O5 \--\> P1     P4 \--\> O7     O10 \--\> D1     D6 \--\> O11     O13 \--\> DV1     DV4 \--\> O14     O15 \--\> Q1     Q5 \--\> O16     O18 \--\> P5     P9 \--\> O19     O20 \--\> User |
| :---- |

Краткое описание ролей в цикле работы оркестратора ИИ агентов:

1. **User (Пользователь)**  
* Роль: Инициатор процесса  
* Отвечает за: Постановку задачи, принятие результата  
* Отчитывается: Не отчитывается (внешний субъект)  
2. **Orchestrator (Координатор)**  
* Роль: Центральный контроллер системы  
* Отвечает за:  
  * Прием задачи от User  
  * Определение недостающих артефактов (архитектура, план, список багов)  
  * Координацию работы всех агентов  
  * Управление статусами задач и переходами между этапами  
  * Уведомление User о готовности  
* Отчитывается: User (финальный результат)  
* Ключевое: Все агенты общаются только через Orchestrator  
3. **Architect (Архитектор)**  
* Роль: Проектировщик системы  
* Отвечает за:  
  * Анализ требований и проектирование архитектуры  
  * Выбор технологического стека  
  * Создание артефакта с описанием устройства системы  
* Отчитывается: Orchestrator (возвращает артефакт архитектуры)  
4. **Planner (Планировщик)**  
* Роль: Декомпозитор и планировщик задач  
* Отвечает за:  
  * Создание плана задач на основе архитектуры  
  * Определение зависимостей между задачами  
  * Обновление плана при получении баг\-репортов от QA  
* Отчитывается: Orchestrator (возвращает/обновляет план задач)  
5. **Developer (Разработчик)**  
* Роль: Реализатор функционала  
* Отвечает за:  
  * Разработку решения и написание кода  
  * Самопроверку кода (линтер, тесты, покрытие, конвенции)  
  * Мердж проверенного кода в основную ветку  
* Отчитывается: Orchestrator (возвращает отчет о завершении задачи)  
6. **DevOps (Инфраструктурщик)**  
* Роль: Инженер развертывания  
* Отвечает за:  
  * Сборку проекта из основной ветки  
  * Развертывание на **тестовом** окружении  
* Отчитывается: Orchestrator (возвращает ссылку на развернутый проект)  
7. **QA (Контроль качества)**  
* Роль: Тестировщик системы  
* Отвечает за:  
  * Тестирование всей системы после развертывания  
  * Выявление багов и несоответствий требованиям  
  * Формирование детального баг\-репорта  
* Отчитывается: Planner (возвращает баг\-репорт для создания новых задач)

### Ключевые принципы взаимодействия

1. Все роли взаимодействуют через Orchestrator.  
2. Developer самостоятельно проверяет качество кода перед мерджем.  
3. CAFC dockets can not be downloaded by Pro userCAFC dockets can not be downloaded by Pro user.  
4. Процесс разработки повторяется до успешного прохождения QA.  
5. QA отчитывается Planner-у, который создает задачи на исправление.  
6. **Не блокирующие друг друга задачи могут разрабатываться параллельно. Оркестратор может спавнить нужное количество агентов под доступные для параллелизации задачи.**

### Частные случаи и потенциальные проблемы

Хотя цель оркестратора \- “раздавать задачи”, но это только в идеальном мире будет работать без проблем. Он (или что-то еще) также должен реагировать на повторяющиеся паттерны. Ниже несколько примеров:

1. Разработчик не может завершить задачу N раз  
   1. Заменить модель разработчика на более смышленую  
   2. Заменить одного агента на другого (Codex \-\> Claude, etc)  
   3. Перепланировать задачу  
   4. Перепланировать архитектуру  
2. Любой из агентов вернул неверный / неподходящий / некачественный вывод \- тюнинг задачи и перезапуск работы.  
3. Неразрешимые противоречия у агентов \- ретроспективный анализ, формирование Lessons Learned, перезапуск цикла целиком или с необходимой точки с обновлением вводных по задаче пользователя, архитектуре, планированию.  
4. Если входит проект, в котором уже есть код \- кто-то должен заняться рисерчем, проиндексировать код.

Таких проблем может быть очень много и сейчас не представляется возможным определить и решить их все. Это будем делать эволюционно. Но возможно стоит заложить механизм или роль, которая будет следить за такими вещами и при необходимости оценивать ситуацию, вмешиваться и корректировать курс или перезапускать работу. Во многих аналогичных решениях подразумевается, что это должен делать человек, но человек не справится с такими объемами данных, сделает свою работу лениво или сожжет много времени. Это надо делать программными средствами.

## Инструментарий

Список инструментов, который заслуживает внимания:

1. [https://github.com/steveyegge/beads](https://github.com/steveyegge/beads)  
2. [https://github.com/getzep/graphiti](https://github.com/getzep/graphiti)  
3. [https://github.com/anthropics/claude-agent-sdk-python](https://github.com/anthropics/claude-agent-sdk-python)  
4. [https://git-scm.com/docs/git-worktree](https://git-scm.com/docs/git-worktree)  
5. [https://github.com/openai/codex/tree/main/codex-cli](https://github.com/openai/codex/tree/main/codex-cli)  
6. [https://ampcode.com/news/python-sdk](https://ampcode.com/news/python-sdk)  
7. [https://github.com/google-gemini/gemini-cli](https://github.com/google-gemini/gemini-cli)

## Что тут еще не хватает?

* подхода к гранулярному цепочному планированию (а-ля \`[beads](https://github.com/steveyegge/beads)\` или что-то еще)  
* стратегия изолированной разработки, чтобы агенты не съебались (при этом изоляция должна быть легковесной, недорогой, быстроразворачиваемой, быстроубиваемой, чтобы оркестратор мог спокойно пинговать или чекать агента внутри его изоляции)  
* не описан подход накапливания знаний \`lessons learned\` и последующего использования его (что-то вроде полевых заметок которые потом прорастают в конституцию). тут много подходов, можно повыбирать и сделать комбинацию:  
  * **git-based Memory** \- агент научен писать развернутые комит мессаджи, агент научен ходить в гит чтоб добывать контекст (\`git log\`)  
  * **plans-n-tasks memory** \- планировщик создает атомарные связанные друг с другом задачи, которые не удаляются, а остаются в проекте вечно, давая агентам по ним ходить для добычи контекста. Так работает \`beads\` в \`gastown\`  
    * *планирование*: Задачи выстраиваются в цепочки ("четки") через зависимости \`depends\_on\`.  
    * *память*: В бусинах хранится состояние агента (\`agent\_state\`) и ссылка на текущую работу (\`hook\_bead\`).  
  * **context files** \- агент после выполнения задачи формируют трейс-артефакт, который ложится в репозиторий и агенты знают где они лежат и как в них онбордиться  
  * **CRAG \- Context RAG** \- агент решил сложный баг и положил знание о решении в векторную базу. агенты научены ходить в векторную базу за добычей контекста (свой тул)  
  * **Reasoning Bank** \- агент после сложной задачи сохраняет цепочку рассуждений, чтобы в будущем понимать контекст принятых решений. Можно положить это в \`CRAG\`, либо сохранять цепочки рассуждений только в особых случаях  
* автоматическое или ручное использование хуков. например хук может быть такой: "Автоматический запуск линтера после каждого изменения файла. Если линтер ругается — отменить изменение."  
* **IMR (Intent-Motivation-Role)** подход. Пока что не описан реестр ролей агентов и их маршрутизация в зависимости от задачи юзера.   
  * Юзер может написать "в базе данных бардах", значит это транслируется в \`DB\_ISSUE\`, а значит должен быть подключена ангенская роль \`DB\_AGENT\` (саму задачу под этой ролью может исполнить любой агент).   
  * Или задача может появится сама (авто-задачи на code health и секьюрити) и флит понимает что туда надо закидывать агентов с нужными ролями. От инстанса к инстансу (компания, отдел, команда разработки) палитра \`IMR\` может отличаться и надо давать ее настраивать  
* Есть проблема доступов, ключей, развертывания на окружение. Многие используют CLI на своих машинах, потому что не хотят конфигурировать сервер так, чтобы там одновременно было много тулов, агентов с доступом к кредам и т.д. В любом случае с компьютера разработчика запуски и работа выглядят “более удобно” и “контролируемо”. Для нас это **ловушка**, потому что кодить решения и деплоить их система должна сама \- а это влечет проблему безопасности, доступа к секретам и т.д.  
  * Оркестратор может деплоить в изолированное безопасное внутреннее облако для приемки.  
  * После приемки проект деплоить в прод должны люди (пока что).

---

Два режима входа: 

- Генерация апок, полный цикл.   
- Генерация фич в проекте

Это один и тот же оркестратор, но с разными режимами работы. Что в генерации апок ему нужна Библия на каждый поток. Поток \- это уникальный стрим ценности. Поток апок у эйчаров может отличаться от потока апок у Аллы, и отличаться от потока апок для отдела маркетинга, или отличатся от потока коммерческих апок условного Телекома или Банка. Точно так же стрим ценности (поток) для фичей одного проекта, отличается от потока фичей для другого проекта. Поток можно зафиксировать в самом первом документе для Флита под кодовым названием “Библия”. Это по сути самый верхний ценностный док. Типа кто ты, что ты, для чего ты, какую цель ты преследуешь, кому и как ты помогаешь. От библии уже выкристаллизовывается вся спека для флита. 

Мы стремимся прийти к такой системе, в которой флит \- это некий витальный “организм”, то есть он функционален но он не “оживлен”. И Библия его оживляет на тот или иной ценностный поток. Может быть два типа библий: одна аповая полноцикловая, вторая фичовая проектая. Сама же библия описывает лишь верхнеуровневый каркас, некую карту, а дальше уже подключаются те или иные “скилы”. Но все равно у каждого потока флита есть свои уникальные подпорки: для эйчаров флит знает куда деплоить ботов, какой тон оф войс им назначать, какие модели им лучше юзать, и так далее. Для флита апок маркетинга, флит знает какой дизайн-код должен быть, на каких тулах это пилить, куда это деплоить, как это мониторить, как это речекать и так далее. Для фичевого флита проекта Энжи флит умеет подхватывать какой-то определенный спектр тасок и допинывать их до пул реквеста с учетом всех регламентов, принятых в проекте. Для фичевого флита Клача Энжи флит может быть проинструктирован полностью обслуживать 3-4 сервисов. Для фичового флита Нево флит научен допинывать таски Давида по продуктовым моментам до мерджа на прод, чтобы его вообще не блочить. 

Как это выглядит вне коробки

- Аповый  
  - **Кыял** выбирает во флите проект Мадина и ставит таску на то что ей надо. Агенты флита если не получили из описания всей картины брифуют Кыял и после маслают пока не задеплоят и не получат от Кыял инпута о том, что все ок.  
  - **Анечка** создает проект во флите на дашборд тех кто больше всего берет авансы. Флоу такой же как у Кыял, только Анечка создает проект с нуля и дальше, когда он уже в продакшене, в этом же проекта добавляет задачи на улучшение и флит их добивает до продакшена.  
- Фичовый   
  - **Enji:** Маша знает какие задачи Энжи флит в состоянии затащить сам и регулярно его кормит этими задачами. Задачи доходят до мерджа и дальше разрабы либо мерджат, либо оставляют комменты отправляя на ревью \- в этом случае флит подхватывает, делает изменения, пингует как обновил МР  
  - **Clutch:** Белек, Вова и Стэн имея флит в Клаче могут ему давать задания любого толка на улучшение тестов, расчистку багов, и прочих технических небольших моментов. Чем больше и лучше они инструктируют флит тем более широкий спектр тасков флит может выгребать.

Работа с флитом происходит через веб интерфейс, где есть проекты, есть длинные задачи. Пользователи флита могут видеть как их задачи делаются, могут видеть что конкретно сейчас делает агент, сколько тасок он уже выполнил, сколько ему осталось, сколько циклов он прошел от плана до результата и обратно, если не принялось, какие агенты на каких этапах были подключены и так далее. Это дает юзерам понимае что в их руках “мини агентсво” по выполнению задач. Это их начнет увлекать и они будут хотеть ставить таски флиту, нежели объяснять что делать разрабам.

Флит будет развиваться бесконечно, так как библий будет куча, проблем будет достаточно, моментов будет много, поэтому у флита нет конечной точки финиша. Флит это бесконечный постоянно увеличивающийся поток ценностей. В итоге Флит с развитием самого себя, с развитием ментальных моделей его создателей и с развитием моделей превратится в полноценную автономную организацию (возможно в 2027 году).

Это значит, что проектирование Флита должно быть таким, чтобы в него можно было как можно раньше начать добавлять пользователей. Это может быть какой очень узкий скоуп, но тот, который надо было бы сделать, но некому, скучно, муторно. Но пользователь знает, что если разгрести это говно, то жить станет лучше. Следовательно разработчикам флита нужно найти некие вертикали которые можно максимально быстро обслужить и сформировать работу флита на этих вертикалях 24 на 7\. 

Флит никогда не должен простаивать. Если флит стоит и ничего не маслает, значит он “на бенче”. Значит пользователи флита не знают что хотят (деградация головы), либо флит кривой и не способен дотащить ценность и пользователи либо не хотят тратить на работу с флитом, либо продолжают ходить к разрабам и врастают в человеческую многоножку.

Магия команды флита должна быть в том, чтобы флит всегда эволюционировал от ценности к ценности. Просто самая первая ценность она малая, узкая, посильная, но **ценность**. Грубо говоря если сделать флит, который идеально создает шутки для Мадины, то этот флит обречен на вымирание. Но если сделать флит, который делает мелкие улучшения по фронтенду Энжи без трогания репозиториев помимо enji front и пускай даже на каждую задачу флит тратит 5-7 часов (разраб бы сделал за 30 минут), то этот флит выживет, так как в него начнут совать еще больше задач, так как появляется положительная обратная связь.

Резюме по трем абзацам выше: Если команда флита начнет его проектировать так, что первые способы работы с ним будут не быстрые и без явного понимания “для кого” \- это все не заведется. То есть команда флита находит сразу потенциальных юзеров с их болями и целится на то, чтобы дать им pain relief.

**Потенциальное развитие флита**

- Коннект с Энжи копилотом, чтобы агенты флита могли добывать контекст либо когда уперлись, либо когда у них нет задач. Если флит подцеплен к Энжи копилоту, то флит может раз в неделю собирать все переписки по чатам и на основе этого генерировать гипотезы фичей, либо гипотезы продукто, либо сразу после этого их имплементить. То есть по сути живой меняющийся контекст в Энжи (скоуп компании или скоуп проекта) может быть для флита сенсорикой которая побуждает его формировать себе же самому задачи.  
- Флит выходит наружу МД и Энжи и становится услугой для клиентов, которые хотят построить себе завод (App Factory & Feature Factory) своих корпоративных приложений, либо своих фич в большой системе. То есть у клиента есть разрабы, но рядом появляется флит, который снимает с разрабов создания скучных прил или скучных фичей. Разрабы становятся мейнтейнерами флита, решателями блокеров, оптимизаторами скорости флита и его ресурсов.   
- Флит выходит внаружу рынка и становится, например, Lovable for Health apps или Bolt for Telegram mini apps with Ton connection.  
- Флит эволюционирует до каркаса автономной компании или автономного отдела.

**Концептуальная топология.**

Вселенная \- это инстанс флита  
Библия \- это вертикаль в инстансе флита, описание “среды” вертикали, описание ценностей этой вертикали, ограничений вертикали.  
Проект \- это проект в инстансе флита по библии (вертикали)  
Задача \- таска в проекте, которые агенты флита катят максимально автономно  
Агент \- по сути существа во вселенной, под влиянием конкретной библии в состоянии дотолкать задачу проекта вертикали.  
Скилы \- конкретные инструментальные “знания” для агентов, грубо говоря навыки. Это широкий концепт, сюда могут входить конституции, способы планирования, подходы к тестированию.  
Роли \- типы поведения агентов (возможно пересекается со скилами, возможно роль это описание поведение для модели и набор скилов).  
Мэмори банк \- проектные знания накапливающиеся по проекту и доступные агентам. Возможно lessons learned могут в дальнейшем превращаться в скилы чтобы стать доступными для всех агентов инстанса  
Таскер \- система формирования, трека, слежения, за задачами агентов. Самое простое это цепочечные атомарные задачи связанные друг с другом, чтобы можно было на любом звене цепи заменить агента без потери контекста.  
   
Чтобы не скатиться в очередной ГасТаун можно опираться на принятые термины в оркестраторах [https://chatgpt.com/s/t\_696def85381481918c9f24e0a4cfc191](https://chatgpt.com/s/t_696def85381481918c9f24e0a4cfc191) 

**Стримы ценности** (люди, которые готовы залетать со своими проблемами сразу же).

Зайтуна для Оптукса. Цель \- построить пайплайн, куда в задачу заносится ключевое слово и дальше по этому ключевому слову пишется текст для толкования этого термина будто ключевое слово это часть глоссария. Далее через Framer API мы коннектимся к [opux.ai](http://opux.ai) и создаем новую страницу для этого термина. Обновляем контент этой страницы. Деплоим страницу. Оповещаем что все готово. Зайтуна на старте готова давать 20 терминов, после ручной проверки и тюнинга промпта для генерации контента на термин выходим на режим 100 терминов в день.

Зайтуна для Mad Devs и Bookinglane. После отладки флоу на Оптуксе натравляем пайп на сайт МД и на сайт коммерческого клиента BL. 

Полезные ссылки 

- [https://openhands.dev/blog/sota-on-swe-bench-verified-with-inference-time-scaling-and-critic-model](https://openhands.dev/blog/sota-on-swe-bench-verified-with-inference-time-scaling-and-critic-model) \- есть бенча для оценки того как плагинг агент спланил задачу и кодинг агенты докодили до результата. В списке соревнующихся есть ЕПАМ, а значит через какое-то время вся сервисная разработка прыгнет на оркестраторы.  
- [https://www.swebench.com/](https://www.swebench.com/) \- пока толком не знаю зачем нам это, но пускай будет  
- [https://refact.ai/](https://refact.ai/) \- интересный продукт, возможно хорошо зайдет для проектного-репозиторского фокуса  
- [https://the-agent-company.com/](https://the-agent-company.com/) \- бенч где соревнуются агенты для решения бытовых типовых задач \- тут прям интересно что какие-то агенты опираются на старые модели [https://the-agent-company.com/\#/leaderboard](https://the-agent-company.com/#/leaderboard)   
- [https://github.com/adityasoni9998/OpenHands-Versa](https://github.com/adityasoni9998/OpenHands-Versa) \- возможен интересный подход к организации работы агентов  
- 

**С чего можно начать** чтобы быстро сварить и начать туда кидаться тасками

- Можно взять за аналогию флоу Google Jules, но заинстуктировать нашего агента так, чтобы он дотаскивал задачу до результата, ибо сам Jules часто останавливается где\-то на середине.  
  - То есть самый первый фокус репозиторный.   
  - Начать можно с того, чтобы ставить любую задачу агенту опираясь на репозиторий. Агент получает таску, знает в какую репу идти, у него есть доступ до репы, он клонирует, делает задачу, оформляет пиарку.   
  - Юзер видит весь процесс  
- Можно взять за аналогию лобабл и просто дать агенту задачу на любое веб\-приложение \- чисто посмотреть поржать над тем как он будет это все доталкивать до конца и что такое конец в этом случае (эволюция планировщика и валидатора)  
- Более крейзи вариант: флит может начать варить сам себя.   
- Fun вариант: берем контекст с Энжи (чаты, таски, люди, активности), сгружаем во флит как сырые сигналы и даем флиту по этим сигналам догадаться какие аппки нужны компании, дальше создается полноценная спека по этой аппке и отдается на кодку. То есть это генератор апок по сигналам. Пример [https://github.com/MeltedMindz/AppFactory](https://github.com/MeltedMindz/AppFactory) 